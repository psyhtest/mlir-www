<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::AffineMap Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">13.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classmlir_1_1AffineMap-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::AffineMap Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A multi-dimensional affine map Affine map's are immutable like <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a>'s, and they are uniqued.  
 <a href="classmlir_1_1AffineMap.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="IR_2AffineMap_8h_source.html">mlir/IR/AffineMap.h</a>&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a491f21c36efbd2ad2e664d16948c016c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a491f21c36efbd2ad2e664d16948c016c">ImplType</a> = <a class="el" href="structmlir_1_1detail_1_1AffineMapStorage.html">detail::AffineMapStorage</a></td></tr>
<tr class="separator:a491f21c36efbd2ad2e664d16948c016c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abafbac6e09e913f062a36a4ce92d5b22"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#abafbac6e09e913f062a36a4ce92d5b22">AffineMap</a> ()</td></tr>
<tr class="separator:abafbac6e09e913f062a36a4ce92d5b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd0836d686d1e4e23f9da8ff0cd54e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a6cd0836d686d1e4e23f9da8ff0cd54e0">AffineMap</a> (<a class="el" href="classmlir_1_1AffineMap.html#a491f21c36efbd2ad2e664d16948c016c">ImplType</a> *map)</td></tr>
<tr class="separator:a6cd0836d686d1e4e23f9da8ff0cd54e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ce6ee55edc21c008a3bf8d10a2d726"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a07ce6ee55edc21c008a3bf8d10a2d726">getContext</a> () const</td></tr>
<tr class="separator:a07ce6ee55edc21c008a3bf8d10a2d726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db87d862458ead8c492e1a05ce18e33"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a4db87d862458ead8c492e1a05ce18e33">operator bool</a> () const</td></tr>
<tr class="separator:a4db87d862458ead8c492e1a05ce18e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7381857cac60752009640964e99172c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a7381857cac60752009640964e99172c2">operator==</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> other) const</td></tr>
<tr class="separator:a7381857cac60752009640964e99172c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad066a62bd10ed01423748bdd913565be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#ad066a62bd10ed01423748bdd913565be">operator!=</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> other) const</td></tr>
<tr class="separator:ad066a62bd10ed01423748bdd913565be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33ea095c58804447510ad5ff023975c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#af33ea095c58804447510ad5ff023975c">isIdentity</a> () const</td></tr>
<tr class="memdesc:af33ea095c58804447510ad5ff023975c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this affine map is an identity affine map.  <a href="#af33ea095c58804447510ad5ff023975c">More...</a><br /></td></tr>
<tr class="separator:af33ea095c58804447510ad5ff023975c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ccbe714fa69ce8426190f88b7854a98"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a1ccbe714fa69ce8426190f88b7854a98">isMinorIdentity</a> () const</td></tr>
<tr class="memdesc:a1ccbe714fa69ce8426190f88b7854a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this affine map is a minor identity, i.e.  <a href="#a1ccbe714fa69ce8426190f88b7854a98">More...</a><br /></td></tr>
<tr class="separator:a1ccbe714fa69ce8426190f88b7854a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753daf697958f1aa999c10c163d3c35b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a753daf697958f1aa999c10c163d3c35b">isMinorIdentityWithBroadcasting</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; *broadcastedDims=nullptr) const</td></tr>
<tr class="memdesc:a753daf697958f1aa999c10c163d3c35b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this affine map is a minor identity up to broadcasted dimensions which are indicated by value 0 in the result.  <a href="#a753daf697958f1aa999c10c163d3c35b">More...</a><br /></td></tr>
<tr class="separator:a753daf697958f1aa999c10c163d3c35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819c4c0117656eae56b72348e469c01e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a819c4c0117656eae56b72348e469c01e">isPermutationOfMinorIdentityWithBroadcasting</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;permutedDims) const</td></tr>
<tr class="memdesc:a819c4c0117656eae56b72348e469c01e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this affine map can be converted to a minor identity with broadcast by doing a permute.  <a href="#a819c4c0117656eae56b72348e469c01e">More...</a><br /></td></tr>
<tr class="separator:a819c4c0117656eae56b72348e469c01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5752e3927fef1c67c276e3aa956e9cfe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a5752e3927fef1c67c276e3aa956e9cfe">isEmpty</a> () const</td></tr>
<tr class="memdesc:a5752e3927fef1c67c276e3aa956e9cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this affine map is an empty map, i.e., () -&gt; ().  <a href="#a5752e3927fef1c67c276e3aa956e9cfe">More...</a><br /></td></tr>
<tr class="separator:a5752e3927fef1c67c276e3aa956e9cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4197b91018d6d6badaccdcb0ce6c1e12"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a4197b91018d6d6badaccdcb0ce6c1e12">isSingleConstant</a> () const</td></tr>
<tr class="memdesc:a4197b91018d6d6badaccdcb0ce6c1e12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this affine map is a single result constant function.  <a href="#a4197b91018d6d6badaccdcb0ce6c1e12">More...</a><br /></td></tr>
<tr class="separator:a4197b91018d6d6badaccdcb0ce6c1e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029344fc35377bfa5b59b51edaf304d9"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a029344fc35377bfa5b59b51edaf304d9">getSingleConstantResult</a> () const</td></tr>
<tr class="memdesc:a029344fc35377bfa5b59b51edaf304d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constant result of this map.  <a href="#a029344fc35377bfa5b59b51edaf304d9">More...</a><br /></td></tr>
<tr class="separator:a029344fc35377bfa5b59b51edaf304d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ecd6ef18c3c3fa94c053f5fba67bdf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#ae0ecd6ef18c3c3fa94c053f5fba67bdf">print</a> (raw_ostream &amp;os) const</td></tr>
<tr class="separator:ae0ecd6ef18c3c3fa94c053f5fba67bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac981930c6d7e6b46b46c4c678d9b5f17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#ac981930c6d7e6b46b46c4c678d9b5f17">dump</a> () const</td></tr>
<tr class="separator:ac981930c6d7e6b46b46c4c678d9b5f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75bef7af11cc1451c2e440718c5a5933"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a75bef7af11cc1451c2e440718c5a5933">getNumDims</a> () const</td></tr>
<tr class="separator:a75bef7af11cc1451c2e440718c5a5933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750b299a4842c7965de35bd2cb1479a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a750b299a4842c7965de35bd2cb1479a0">getNumSymbols</a> () const</td></tr>
<tr class="separator:a750b299a4842c7965de35bd2cb1479a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f194ae3b4baf33c67b10c9f795b564"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a96f194ae3b4baf33c67b10c9f795b564">getNumResults</a> () const</td></tr>
<tr class="separator:a96f194ae3b4baf33c67b10c9f795b564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa821f07143bcad97d6df532c232129a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#aa821f07143bcad97d6df532c232129a3">getNumInputs</a> () const</td></tr>
<tr class="separator:aa821f07143bcad97d6df532c232129a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79007ce78cfccb064390c22a4af6037c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a79007ce78cfccb064390c22a4af6037c">getResults</a> () const</td></tr>
<tr class="separator:a79007ce78cfccb064390c22a4af6037c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60458b2cba87d765341cd6b2d41ed12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#ac60458b2cba87d765341cd6b2d41ed12">getResult</a> (<a class="el" href="classunsigned.html">unsigned</a> idx) const</td></tr>
<tr class="separator:ac60458b2cba87d765341cd6b2d41ed12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff49306f1f5459448db5f41c55daa3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a1ff49306f1f5459448db5f41c55daa3e">getDimPosition</a> (<a class="el" href="classunsigned.html">unsigned</a> idx) const</td></tr>
<tr class="memdesc:a1ff49306f1f5459448db5f41c55daa3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the position of the dimensional expression at the given result, when the caller knows it is safe to do so.  <a href="#a1ff49306f1f5459448db5f41c55daa3e">More...</a><br /></td></tr>
<tr class="separator:a1ff49306f1f5459448db5f41c55daa3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173d3fd01950f75a2285a872b22e2c48"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a173d3fd01950f75a2285a872b22e2c48">isFunctionOfDim</a> (<a class="el" href="classunsigned.html">unsigned</a> position) const</td></tr>
<tr class="memdesc:a173d3fd01950f75a2285a872b22e2c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any affine expression involves <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression. ">AffineDimExpr</a> <code>position</code>.  <a href="#a173d3fd01950f75a2285a872b22e2c48">More...</a><br /></td></tr>
<tr class="separator:a173d3fd01950f75a2285a872b22e2c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df13ef25920c15d07c7bc9686b26be7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a7df13ef25920c15d07c7bc9686b26be7">isFunctionOfSymbol</a> (<a class="el" href="classunsigned.html">unsigned</a> position) const</td></tr>
<tr class="memdesc:a7df13ef25920c15d07c7bc9686b26be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any affine expression involves <a class="el" href="classmlir_1_1AffineSymbolExpr.html" title="A symbolic identifier appearing in an affine expression. ">AffineSymbolExpr</a> <code>position</code>.  <a href="#a7df13ef25920c15d07c7bc9686b26be7">More...</a><br /></td></tr>
<tr class="separator:a7df13ef25920c15d07c7bc9686b26be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113361b495944795b99c988b9f658702"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a113361b495944795b99c988b9f658702">walkExprs</a> (std::function&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>)&gt; callback) const</td></tr>
<tr class="memdesc:a113361b495944795b99c988b9f658702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk all of the <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a>'s in this mapping.  <a href="#a113361b495944795b99c988b9f658702">More...</a><br /></td></tr>
<tr class="separator:a113361b495944795b99c988b9f658702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1fdca78f9d7bde157d251892dd99fa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#aa1fdca78f9d7bde157d251892dd99fa8">replaceDimsAndSymbols</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; dimReplacements, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; symReplacements, <a class="el" href="classunsigned.html">unsigned</a> numResultDims, <a class="el" href="classunsigned.html">unsigned</a> numResultSyms) const</td></tr>
<tr class="memdesc:aa1fdca78f9d7bde157d251892dd99fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method substitutes any uses of dimensions and symbols (e.g.  <a href="#aa1fdca78f9d7bde157d251892dd99fa8">More...</a><br /></td></tr>
<tr class="separator:aa1fdca78f9d7bde157d251892dd99fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d5c7e20f021aac37fcb4e65cbfca8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#ac7d5c7e20f021aac37fcb4e65cbfca8c">replace</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> replacement, <a class="el" href="classunsigned.html">unsigned</a> numResultDims, <a class="el" href="classunsigned.html">unsigned</a> numResultSyms) const</td></tr>
<tr class="memdesc:ac7d5c7e20f021aac37fcb4e65cbfca8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse replace method.  <a href="#ac7d5c7e20f021aac37fcb4e65cbfca8c">More...</a><br /></td></tr>
<tr class="separator:ac7d5c7e20f021aac37fcb4e65cbfca8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4822614b5ae9d1f80e0b3da7b3ce664d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a4822614b5ae9d1f80e0b3da7b3ce664d">replace</a> (const <a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; &amp;map, <a class="el" href="classunsigned.html">unsigned</a> numResultDims, <a class="el" href="classunsigned.html">unsigned</a> numResultSyms) const</td></tr>
<tr class="memdesc:a4822614b5ae9d1f80e0b3da7b3ce664d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse replace method.  <a href="#a4822614b5ae9d1f80e0b3da7b3ce664d">More...</a><br /></td></tr>
<tr class="separator:a4822614b5ae9d1f80e0b3da7b3ce664d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ba29799ec6508e4de245202dec38e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a10ba29799ec6508e4de245202dec38e8">shiftDims</a> (<a class="el" href="classunsigned.html">unsigned</a> shift) const</td></tr>
<tr class="memdesc:a10ba29799ec6508e4de245202dec38e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace dims[0 .. numDims - 1] by dims[shift .. shift + numDims - 1].  <a href="#a10ba29799ec6508e4de245202dec38e8">More...</a><br /></td></tr>
<tr class="separator:a10ba29799ec6508e4de245202dec38e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaac1516f0672a778670fb435a4ddc4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#aeaac1516f0672a778670fb435a4ddc4a">shiftSymbols</a> (<a class="el" href="classunsigned.html">unsigned</a> shift) const</td></tr>
<tr class="memdesc:aeaac1516f0672a778670fb435a4ddc4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace symbols[0 .  <a href="#aeaac1516f0672a778670fb435a4ddc4a">More...</a><br /></td></tr>
<tr class="separator:aeaac1516f0672a778670fb435a4ddc4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ca0db439fef10258b8936b78a26f80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a91ca0db439fef10258b8936b78a26f80">constantFold</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operandConstants, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; &amp;results) const</td></tr>
<tr class="memdesc:a91ca0db439fef10258b8936b78a26f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Folds the results of the application of an affine map on the provided operands to a constant if possible.  <a href="#a91ca0db439fef10258b8936b78a26f80">More...</a><br /></td></tr>
<tr class="separator:a91ca0db439fef10258b8936b78a26f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17616a46809bbfc6a46d16186817201d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a17616a46809bbfc6a46d16186817201d">partialConstantFold</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operandConstants, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *results=nullptr) const</td></tr>
<tr class="memdesc:a17616a46809bbfc6a46d16186817201d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagates the constant operands into this affine map.  <a href="#a17616a46809bbfc6a46d16186817201d">More...</a><br /></td></tr>
<tr class="separator:a17616a46809bbfc6a46d16186817201d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2baf4561cf7d74a9959fd9e875c9a82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#af2baf4561cf7d74a9959fd9e875c9a82">compose</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map) const</td></tr>
<tr class="memdesc:af2baf4561cf7d74a9959fd9e875c9a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a> resulting from composing <code>this</code> with <code>map</code>.  <a href="#af2baf4561cf7d74a9959fd9e875c9a82">More...</a><br /></td></tr>
<tr class="separator:af2baf4561cf7d74a9959fd9e875c9a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c205e3ff1701beab13d721c11031ed2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a7c205e3ff1701beab13d721c11031ed2">compose</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; values) const</td></tr>
<tr class="memdesc:a7c205e3ff1701beab13d721c11031ed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies composition by the dims of <code>this</code> to the integer <code>values</code> and returns the resulting values.  <a href="#a7c205e3ff1701beab13d721c11031ed2">More...</a><br /></td></tr>
<tr class="separator:a7c205e3ff1701beab13d721c11031ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a197911eedb042527da82f693725fa041"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a197911eedb042527da82f693725fa041">isProjectedPermutation</a> () const</td></tr>
<tr class="memdesc:a197911eedb042527da82f693725fa041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a> represents a subset (i.e.  <a href="#a197911eedb042527da82f693725fa041">More...</a><br /></td></tr>
<tr class="separator:a197911eedb042527da82f693725fa041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e665372add0df0668e1ebd231488b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#af6e665372add0df0668e1ebd231488b4">isPermutation</a> () const</td></tr>
<tr class="memdesc:af6e665372add0df0668e1ebd231488b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a> represents a symbol-less permutation map.  <a href="#af6e665372add0df0668e1ebd231488b4">More...</a><br /></td></tr>
<tr class="separator:af6e665372add0df0668e1ebd231488b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add23e0ad557890ca7113d38e96c4c870"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#add23e0ad557890ca7113d38e96c4c870">getSubMap</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; resultPos) const</td></tr>
<tr class="memdesc:add23e0ad557890ca7113d38e96c4c870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the map consisting of the <code>resultPos</code> subset.  <a href="#add23e0ad557890ca7113d38e96c4c870">More...</a><br /></td></tr>
<tr class="separator:add23e0ad557890ca7113d38e96c4c870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054f395f1fc7a1db524caa616e460bed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a054f395f1fc7a1db524caa616e460bed">getSliceMap</a> (<a class="el" href="classunsigned.html">unsigned</a> start, <a class="el" href="classunsigned.html">unsigned</a> length) const</td></tr>
<tr class="memdesc:a054f395f1fc7a1db524caa616e460bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the map consisting of <code>length</code> expressions starting from <code>start</code>.  <a href="#a054f395f1fc7a1db524caa616e460bed">More...</a><br /></td></tr>
<tr class="separator:a054f395f1fc7a1db524caa616e460bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06383d6033de3ed99168e650abaaf66d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a06383d6033de3ed99168e650abaaf66d">getMajorSubMap</a> (<a class="el" href="classunsigned.html">unsigned</a> numResults) const</td></tr>
<tr class="memdesc:a06383d6033de3ed99168e650abaaf66d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the map consisting of the most major <code>numResults</code> results.  <a href="#a06383d6033de3ed99168e650abaaf66d">More...</a><br /></td></tr>
<tr class="separator:a06383d6033de3ed99168e650abaaf66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481ad498d786f3c6e9b17965ea1d83a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a481ad498d786f3c6e9b17965ea1d83a8">getMinorSubMap</a> (<a class="el" href="classunsigned.html">unsigned</a> numResults) const</td></tr>
<tr class="memdesc:a481ad498d786f3c6e9b17965ea1d83a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the map consisting of the most minor <code>numResults</code> results.  <a href="#a481ad498d786f3c6e9b17965ea1d83a8">More...</a><br /></td></tr>
<tr class="separator:a481ad498d786f3c6e9b17965ea1d83a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9eca294f05e4106eadadcb1e5d6b36"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvoid.html">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#aaf9eca294f05e4106eadadcb1e5d6b36">getAsOpaquePointer</a> () const</td></tr>
<tr class="memdesc:aaf9eca294f05e4106eadadcb1e5d6b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods supporting C API.  <a href="#aaf9eca294f05e4106eadadcb1e5d6b36">More...</a><br /></td></tr>
<tr class="separator:aaf9eca294f05e4106eadadcb1e5d6b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a3cfca2eb29fddf3c4bda714cccaa53f9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a3cfca2eb29fddf3c4bda714cccaa53f9">get</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a3cfca2eb29fddf3c4bda714cccaa53f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a zero result affine map with no dimensions or symbols: () -&gt; ().  <a href="#a3cfca2eb29fddf3c4bda714cccaa53f9">More...</a><br /></td></tr>
<tr class="separator:a3cfca2eb29fddf3c4bda714cccaa53f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0742d98deb42f72abc9a7b2fa232dc8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#ad0742d98deb42f72abc9a7b2fa232dc8">get</a> (<a class="el" href="classunsigned.html">unsigned</a> dimCount, <a class="el" href="classunsigned.html">unsigned</a> symbolCount, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:ad0742d98deb42f72abc9a7b2fa232dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a zero result affine map with <code>dimCount</code> dimensions and <code>symbolCount</code> symbols, e.g.  <a href="#ad0742d98deb42f72abc9a7b2fa232dc8">More...</a><br /></td></tr>
<tr class="separator:ad0742d98deb42f72abc9a7b2fa232dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb27ba563698d7152eced09f1c5a99c6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#aeb27ba563698d7152eced09f1c5a99c6">get</a> (<a class="el" href="classunsigned.html">unsigned</a> dimCount, <a class="el" href="classunsigned.html">unsigned</a> symbolCount, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> result)</td></tr>
<tr class="memdesc:aeb27ba563698d7152eced09f1c5a99c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an affine map with <code>dimCount</code> dimensions and <code>symbolCount</code> mapping to a single output dimension.  <a href="#aeb27ba563698d7152eced09f1c5a99c6">More...</a><br /></td></tr>
<tr class="separator:aeb27ba563698d7152eced09f1c5a99c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05f70527f322fb8d381e416a96db44d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#aa05f70527f322fb8d381e416a96db44d">get</a> (<a class="el" href="classunsigned.html">unsigned</a> dimCount, <a class="el" href="classunsigned.html">unsigned</a> symbolCount, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; results, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:aa05f70527f322fb8d381e416a96db44d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an affine map with <code>dimCount</code> dimensions and <code>symbolCount</code> mapping to the given results.  <a href="#aa05f70527f322fb8d381e416a96db44d">More...</a><br /></td></tr>
<tr class="separator:aa05f70527f322fb8d381e416a96db44d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98c7861efe6542d1e99c8172cc6061a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#ad98c7861efe6542d1e99c8172cc6061a">getConstantMap</a> (int64_t val, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:ad98c7861efe6542d1e99c8172cc6061a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a single constant result affine map.  <a href="#ad98c7861efe6542d1e99c8172cc6061a">More...</a><br /></td></tr>
<tr class="separator:ad98c7861efe6542d1e99c8172cc6061a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ed2c2a4c743450a4a999fa6db1bf84"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a39ed2c2a4c743450a4a999fa6db1bf84">getMultiDimIdentityMap</a> (<a class="el" href="classunsigned.html">unsigned</a> numDims, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a39ed2c2a4c743450a4a999fa6db1bf84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a> with 'numDims' identity result dim exprs.  <a href="#a39ed2c2a4c743450a4a999fa6db1bf84">More...</a><br /></td></tr>
<tr class="separator:a39ed2c2a4c743450a4a999fa6db1bf84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a035fc7c93286e3aa0354f522f2cd885a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a035fc7c93286e3aa0354f522f2cd885a">getMinorIdentityMap</a> (<a class="el" href="classunsigned.html">unsigned</a> dims, <a class="el" href="classunsigned.html">unsigned</a> results, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a035fc7c93286e3aa0354f522f2cd885a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an identity affine map (d0, ..., dn) -&gt; (dp, ..., dn) on the most minor dimensions.  <a href="#a035fc7c93286e3aa0354f522f2cd885a">More...</a><br /></td></tr>
<tr class="separator:a035fc7c93286e3aa0354f522f2cd885a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd08312b1039c20f008d2f6785c47816"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#acd08312b1039c20f008d2f6785c47816">getPermutationMap</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; permutation, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:acd08312b1039c20f008d2f6785c47816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a> representing a permutation.  <a href="#acd08312b1039c20f008d2f6785c47816">More...</a><br /></td></tr>
<tr class="separator:acd08312b1039c20f008d2f6785c47816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadfe536e16fe5c891a482d816cd33ede"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#aadfe536e16fe5c891a482d816cd33ede">inferFromExprList</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&gt; exprsList)</td></tr>
<tr class="memdesc:aadfe536e16fe5c891a482d816cd33ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of AffineMaps; each with as many results as <code>exprs.size()</code>, as many dims as the largest dim in <code>exprs</code> and as many symbols as the largest symbol in <code>exprs</code>.  <a href="#aadfe536e16fe5c891a482d816cd33ede">More...</a><br /></td></tr>
<tr class="separator:aadfe536e16fe5c891a482d816cd33ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d944ece09b92ecacf206d2f377fa99f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a2d944ece09b92ecacf206d2f377fa99f">inferFromExprList</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 4 &gt;&gt; exprsList)</td></tr>
<tr class="separator:a2d944ece09b92ecacf206d2f377fa99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdf41a0f3fee3a701ee651d40306a1c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#aacdf41a0f3fee3a701ee651d40306a1c">getFromOpaquePointer</a> (const <a class="el" href="classvoid.html">void</a> *pointer)</td></tr>
<tr class="separator:aacdf41a0f3fee3a701ee651d40306a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a07dc7e1df4f0d9e9c4d1038f7a688527"><td class="memItemLeft" align="right" valign="top">::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a07dc7e1df4f0d9e9c4d1038f7a688527">hash_value</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> arg)</td></tr>
<tr class="separator:a07dc7e1df4f0d9e9c4d1038f7a688527"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A multi-dimensional affine map Affine map's are immutable like <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a>'s, and they are uniqued. </p>
<p>Eg: (d0, d1) -&gt; (d0/128, d0 mod 128, d1) The names used (d0, d1) don't matter - it's the mathematical function that is unique to this affine map. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8h_source.html#l00038">38</a> of file <a class="el" href="IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a491f21c36efbd2ad2e664d16948c016c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a491f21c36efbd2ad2e664d16948c016c">&#9670;&nbsp;</a></span>ImplType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmlir_1_1AffineMap.html#a491f21c36efbd2ad2e664d16948c016c">mlir::AffineMap::ImplType</a> =  <a class="el" href="structmlir_1_1detail_1_1AffineMapStorage.html">detail::AffineMapStorage</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8h_source.html#l00040">40</a> of file <a class="el" href="IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abafbac6e09e913f062a36a4ce92d5b22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abafbac6e09e913f062a36a4ce92d5b22">&#9670;&nbsp;</a></span>AffineMap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mlir::AffineMap::AffineMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8h_source.html#l00042">42</a> of file <a class="el" href="IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

</div>
</div>
<a id="a6cd0836d686d1e4e23f9da8ff0cd54e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cd0836d686d1e4e23f9da8ff0cd54e0">&#9670;&nbsp;</a></span>AffineMap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::AffineMap::AffineMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html#a491f21c36efbd2ad2e664d16948c016c">ImplType</a> *&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8h_source.html#l00043">43</a> of file <a class="el" href="IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00235">inferFromExprList()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af2baf4561cf7d74a9959fd9e875c9a82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2baf4561cf7d74a9959fd9e875c9a82">&#9670;&nbsp;</a></span>compose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::compose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a> resulting from composing <code>this</code> with <code>map</code>. </p>
<p>The resulting <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a> has as many <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression. ">AffineDimExpr</a> as <code>map</code> and as many <a class="el" href="classmlir_1_1AffineSymbolExpr.html" title="A symbolic identifier appearing in an affine expression. ">AffineSymbolExpr</a> as the concatenation of <code>this</code> and <code>map</code> (in which case the symbols of <code>this</code> map come first).</p>
<p>Prerequisites: The maps are composable, i.e. that the number of <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression. ">AffineDimExpr</a> of <code>this</code> matches the number of results of <code>map</code>.</p>
<p>Example: map1: <code>(d0, d1)[s0, s1] -&gt; (d0 + 1 + s1, d1 - 1 - s0)</code> map2: <code>(d0)[s0] -&gt; (d0 + s0, d0 - s0)</code> map1.compose(map2): <code>(d0)[s0, s1, s2] -&gt; (d0 + s1 + s2 + 1, d0 - s0 - s2 - 1)</code> </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00428">428</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00840">mlir::AffineExpr::compose()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00957">get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00482">mlir::getAffineDimExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00492">mlir::getAffineSymbolExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00268">getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00295">getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00303">getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00299">getNumSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">replaceDimsAndSymbols()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8cpp_source.html#l00960">foldExtractOpFromInsertChainAndTranspose()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00902">foldExtractOpFromTranspose()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00248">fuseElementwiseOpsImpl()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00065">getIndexingMapOfProducerOperandsInCoordinatesOfFusedOp()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00690">mlir::getStridesAndOffset()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01994">inferTransposeResultType()</a>, <a class="el" href="Interchange_8cpp_source.html#l00052">mlir::linalg::interchange()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02929">TransferReadPermutationLowering::matchAndRewrite()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00457">vectorizeAsLinalgGeneric()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00547">vectorizeContraction()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00445">verifyOutputShape()</a>, and <a class="el" href="LinalgInterfaces_8cpp_source.html#l00254">HasAffineDimExprVisitor::visitSymbolExpr()</a>.</p>

</div>
</div>
<a id="a7c205e3ff1701beab13d721c11031ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c205e3ff1701beab13d721c11031ed2">&#9670;&nbsp;</a></span>compose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 4 &gt; AffineMap::compose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies composition by the dims of <code>this</code> to the integer <code>values</code> and returns the resulting values. </p>
<p><code>this</code> must be symbol-less. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00452">452</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00957">get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00507">mlir::getAffineConstantExpr()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00499">mlir::AffineConstantExpr::getValue()</a>.</p>

</div>
</div>
<a id="a91ca0db439fef10258b8936b78a26f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ca0db439fef10258b8936b78a26f80">&#9670;&nbsp;</a></span>constantFold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> AffineMap::constantFold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>operandConstants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Folds the results of the application of an affine map on the provided operands to a constant if possible. </p>
<p>Returns false if the folding happens, true otherwise. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00329">329</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01526">foldLoopBounds()</a>.</p>

</div>
</div>
<a id="ac981930c6d7e6b46b46c4c678d9b5f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac981930c6d7e6b46b46c4c678d9b5f17">&#9670;&nbsp;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> AffineMap::dump </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsmPrinter_8cpp_source.html#l02629">2629</a> of file <a class="el" href="AsmPrinter_8cpp_source.html">AsmPrinter.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Shape_2IR_2Shape_8cpp_source.html#l00984">print()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Analysis_2Utils_8cpp_source.html#l00443">mlir::MemRefRegion::compute()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01841">mlir::FlatAffineConstraints::getSliceBounds()</a>.</p>

</div>
</div>
<a id="a3cfca2eb29fddf3c4bda714cccaa53f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cfca2eb29fddf3c4bda714cccaa53f9">&#9670;&nbsp;</a></span>get() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a zero result affine map with no dimensions or symbols: () -&gt; (). </p>

<p class="definition">Definition at line <a class="el" href="MLIRContext_8cpp_source.html#l00957">957</a> of file <a class="el" href="MLIRContext_8cpp_source.html">MLIRContext.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8h_source.html#l00143">mlir::MLIRContext::getImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorTransforms_8cpp_source.html#l00075">adjustMap()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00169">mlir::linalg::applyMapToValues()</a>, <a class="el" href="VectorToSCF_8cpp_source.html#l00045">applyMapToValues()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01664">augmentMapAndBounds()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00033">mlir::buildTripCountMapAndOperands()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01285">calculateImplicitMap()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00844">mlir::canonicalizeStridedLayout()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01107">collapseReassociationMaps()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00428">compose()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00519">mlir::compressDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00587">mlir::compressSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00552">compressUnusedImpl()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l00793">computeMemoryOpIndices()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00667">mlir::concatAffineMaps()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00836">constructTiledIndexSetHyperRect()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00316">mlir::createAffineComputationSlice()</a>, <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00103">createBinaryIndexHandle()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l00887">createPrivateMemRef()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00026">mlir::AffineValueMap::difference()</a>, <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00066">doubleBuffer()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00443">elementwiseMatchAndRewriteHelper()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l02404">mlir::linalg::extractOrIdentityMap()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00902">foldExtractOpFromTranspose()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01976">foldExtractStridedOpFromInsertChain()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00802">fuseWithReshapeByExpansion()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02356">generateCopy()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02267">generatePointWiseCopy()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00519">generateTransferOpSlices()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00729">mlir::MutableAffineMap::getAffineMap()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00058">getCleanupLoopLowerBound()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01372">getCollapsedOutputDimFromInputShape()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00316">mlir::Builder::getConstantAffineMap()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00321">mlir::Builder::getDimIdentityMap()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00314">mlir::Builder::getEmptyAffineMap()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01423">getExpandedOutputDimFromInputShape()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00652">getIndexingMapInExpandedOp()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03232">mlir::FlatAffineConstraints::getIneqAsAffineValueMap()</a>, <a class="el" href="LinalgToSPIRV_8cpp_source.html#l00029">getLocalInvocationDimSize()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01753">mlir::FlatAffineConstraints::getLowerAndUpperBound()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00102">getMinorIdentityMap()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00325">mlir::Builder::getMultiDimIdentityMap()</a>, <a class="el" href="Loops_8cpp_source.html#l00178">getPaddedInput()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00205">getPermutationMap()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00345">mlir::Builder::getShiftedAffineMap()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00339">mlir::Builder::getSingleDimShiftAffineMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01841">mlir::FlatAffineConstraints::getSliceBounds()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00497">getSliceMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00489">getSubMap()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00334">mlir::Builder::getSymbolIdentityMap()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01340">getSymbolLessAffineMaps()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00235">inferFromExprList()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00643">mlir::inversePermutation()</a>, <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00041">mlir::isColumnMajorMatmul()</a>, <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00067">mlir::isRowMajorBatchMatmul()</a>, <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00015">mlir::isRowMajorMatmul()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00375">linearizeCollapsedDims()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01119">mlir::loopUnrollByFactor()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01319">mlir::loopUnrollJamByFactor()</a>, <a class="el" href="Loops_8cpp_source.html#l00036">makeCanonicalAffineApplies()</a>, <a class="el" href="VectorUtils_8cpp_source.html#l00174">makePermutationMap()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00803">mlir::makeStridedLinearLayoutMap()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00488">mlir::linalg::makeTiledShapes()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02148">mlir::mapLoopToProcessorIds()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01770">mlir::ContractionOpToMatmulOpLowering::matchAndRewrite()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00595">mlir::linalg::AffineMinRangeCanonicalizationPattern::matchAndRewrite()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00722">mlir::linalg::ConvOpVectorization&lt; ConvOp, N &gt;::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02337">DeduplicateAffineMinMaxExpressions&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02380">MergeAffineMinMaxOp&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02974">TransferOpReduceRank::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l03124">CastAwayTransferReadLeadingOneDim::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l03167">CastAwayTransferWriteLeadingOneDim::matchAndRewrite()</a>, <a class="el" href="CAPI_2IR_2AffineMap_8cpp_source.html#l00037">mlirAffineMapEmptyGet()</a>, <a class="el" href="CAPI_2IR_2AffineMap_8cpp_source.html#l00046">mlirAffineMapGet()</a>, <a class="el" href="CAPI_2IR_2AffineMap_8cpp_source.html#l00041">mlirAffineMapZeroResultGet()</a>, <a class="el" href="AffineLoopNormalize_8cpp_source.html#l00094">normalizeAffineFor()</a>, <a class="el" href="AffineLoopNormalize_8cpp_source.html#l00023">mlir::normalizeAffineParallel()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03025">parseAffineMapWithMinMax()</a>, <a class="el" href="SCFToGPU_8cpp_source.html#l00378">processParallelLoop()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00647">reduceMatchAndRewriteHelper()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00634">mlir::removeDuplicateExprs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00405">replace()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00030">mlir::replaceAllMemRefUsesWith()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00300">replaceUnitExtents()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00707">setInterTileBoundsParametric()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00612">setIntraTileBoundsParametric()</a>, <a class="el" href="IR_2AffineMap_8h_source.html#l00199">shiftDims()</a>, <a class="el" href="IR_2AffineMap_8h_source.html#l00210">shiftSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00624">mlir::simplifyAffineMap()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00512">substitute()</a>, <a class="el" href="ParallelLoopTiling_8cpp_source.html#l00041">mlir::scf::tileParallelLoop()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02565">verify()</a>, and <a class="el" href="VectorOps_8cpp_source.html#l00445">verifyOutputShape()</a>.</p>

</div>
</div>
<a id="ad0742d98deb42f72abc9a7b2fa232dc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0742d98deb42f72abc9a7b2fa232dc8">&#9670;&nbsp;</a></span>get() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>dimCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>symbolCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a zero result affine map with <code>dimCount</code> dimensions and <code>symbolCount</code> symbols, e.g. </p>
<p>: <code>(...) -&gt; ()</code>. </p>

<p class="definition">Definition at line <a class="el" href="MLIRContext_8cpp_source.html#l00961">961</a> of file <a class="el" href="MLIRContext_8cpp_source.html">MLIRContext.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8h_source.html#l00143">mlir::MLIRContext::getImpl()</a>.</p>

</div>
</div>
<a id="aeb27ba563698d7152eced09f1c5a99c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb27ba563698d7152eced09f1c5a99c6">&#9670;&nbsp;</a></span>get() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>dimCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>symbolCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an affine map with <code>dimCount</code> dimensions and <code>symbolCount</code> mapping to a single output dimension. </p>

<p class="definition">Definition at line <a class="el" href="MLIRContext_8cpp_source.html#l00966">966</a> of file <a class="el" href="MLIRContext_8cpp_source.html">MLIRContext.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00021">mlir::AffineExpr::getContext()</a>, and <a class="el" href="MLIRContext_8h_source.html#l00143">mlir::MLIRContext::getImpl()</a>.</p>

</div>
</div>
<a id="aa05f70527f322fb8d381e416a96db44d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa05f70527f322fb8d381e416a96db44d">&#9670;&nbsp;</a></span>get() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>dimCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>symbolCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an affine map with <code>dimCount</code> dimensions and <code>symbolCount</code> mapping to the given results. </p>

<p class="definition">Definition at line <a class="el" href="MLIRContext_8cpp_source.html#l00971">971</a> of file <a class="el" href="MLIRContext_8cpp_source.html">MLIRContext.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8h_source.html#l00143">mlir::MLIRContext::getImpl()</a>.</p>

</div>
</div>
<a id="aaf9eca294f05e4106eadadcb1e5d6b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf9eca294f05e4106eadadcb1e5d6b36">&#9670;&nbsp;</a></span>getAsOpaquePointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classvoid.html">void</a>* mlir::AffineMap::getAsOpaquePointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods supporting C API. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8h_source.html#l00281">281</a> of file <a class="el" href="IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

</div>
</div>
<a id="ad98c7861efe6542d1e99c8172cc6061a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad98c7861efe6542d1e99c8172cc6061a">&#9670;&nbsp;</a></span>getConstantMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::getConstantMap </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a single constant result affine map. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00095">95</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00507">mlir::getAffineConstantExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01572">canonicalizeLoopBounds()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01173">mlir::AffineDmaWaitOp::fold()</a>, and <a class="el" href="CAPI_2IR_2AffineMap_8cpp_source.html#l00054">mlirAffineMapConstantGet()</a>.</p>

</div>
</div>
<a id="a07ce6ee55edc21c008a3bf8d10a2d726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ce6ee55edc21c008a3bf8d10a2d726">&#9670;&nbsp;</a></span>getContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> * AffineMap::getContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00268">268</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8cpp_source.html#l00428">compose()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00628">composeAffineMapAndOperands()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00519">mlir::compressDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00587">mlir::compressSymbols()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01976">foldExtractStridedOpFromInsertChain()</a>, <a class="el" href="ParallelLoopMapper_8cpp_source.html#l00033">mlir::gpu::getParallelLoopDimMappingAttr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00643">mlir::inversePermutation()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00375">linearizeCollapsedDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00634">mlir::removeDuplicateExprs()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00585">replaceDimOrSym()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00701">mlir::MutableAffineMap::reset()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00624">mlir::simplifyAffineMap()</a>, and <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00512">substitute()</a>.</p>

</div>
</div>
<a id="a1ff49306f1f5459448db5f41c55daa3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff49306f1f5459448db5f41c55daa3e">&#9670;&nbsp;</a></span>getDimPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> AffineMap::getDimPosition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the position of the dimensional expression at the given result, when the caller knows it is safe to do so. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00321">321</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorTransforms_8cpp_source.html#l00075">adjustMap()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00960">foldExtractOpFromInsertChainAndTranspose()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00802">fuseWithReshapeByExpansion()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00052">getResultIndex()</a>, and <a class="el" href="FusionOnTensors_8cpp_source.html#l00525">isFusableWithReshapeByDimExpansion()</a>.</p>

</div>
</div>
<a id="aacdf41a0f3fee3a701ee651d40306a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacdf41a0f3fee3a701ee651d40306a1c">&#9670;&nbsp;</a></span>getFromOpaquePointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::AffineMap::getFromOpaquePointer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvoid.html">void</a> *&#160;</td>
          <td class="paramname"><em>pointer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8h_source.html#l00284">284</a> of file <a class="el" href="IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

</div>
</div>
<a id="a06383d6033de3ed99168e650abaaf66d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06383d6033de3ed99168e650abaaf66d">&#9670;&nbsp;</a></span>getMajorSubMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::getMajorSubMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numResults</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the map consisting of the most major <code>numResults</code> results. </p>
<p>Returns the null <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a> if <code>numResults</code> == 0. Returns <code>*this</code> if <code>numResults</code> &gt;= <code>this-&gt;<a class="el" href="classmlir_1_1AffineMap.html#a96f194ae3b4baf33c67b10c9f795b564">getNumResults()</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00502">502</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8cpp_source.html#l00902">foldExtractOpFromTranspose()</a>.</p>

</div>
</div>
<a id="a035fc7c93286e3aa0354f522f2cd885a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a035fc7c93286e3aa0354f522f2cd885a">&#9670;&nbsp;</a></span>getMinorIdentityMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::getMinorIdentityMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an identity affine map (d0, ..., dn) -&gt; (dp, ..., dn) on the most minor dimensions. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00102">102</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00957">get()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00259">getMultiDimIdentityMap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorUtils_8cpp_source.html#l00226">getEnclosingforOps()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00221">getTransferOpAdapter()</a>, and <a class="el" href="CAPI_2IR_2AffineMap_8cpp_source.html#l00063">mlirAffineMapMinorIdentityGet()</a>.</p>

</div>
</div>
<a id="a481ad498d786f3c6e9b17965ea1d83a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a481ad498d786f3c6e9b17965ea1d83a8">&#9670;&nbsp;</a></span>getMinorSubMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::getMinorSubMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numResults</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the map consisting of the most minor <code>numResults</code> results. </p>
<p>Returns the null <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a> if <code>numResults</code> == 0. Returns <code>*this</code> if <code>numResults</code> &gt;= <code>this-&gt;<a class="el" href="classmlir_1_1AffineMap.html#a96f194ae3b4baf33c67b10c9f795b564">getNumResults()</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00510">510</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8cpp_source.html#l00960">foldExtractOpFromInsertChainAndTranspose()</a>, and <a class="el" href="VectorOps_8cpp_source.html#l00902">foldExtractOpFromTranspose()</a>.</p>

</div>
</div>
<a id="a39ed2c2a4c743450a4a999fa6db1bf84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39ed2c2a4c743450a4a999fa6db1bf84">&#9670;&nbsp;</a></span>getMultiDimIdentityMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::getMultiDimIdentityMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a> with 'numDims' identity result dim exprs. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00259">259</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00482">mlir::getAffineDimExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgOps_8cpp_source.html#l02404">mlir::linalg::extractOrIdentityMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00102">getMinorIdentityMap()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00722">mlir::linalg::ConvOpVectorization&lt; ConvOp, N &gt;::matchAndRewrite()</a>, <a class="el" href="CAPI_2IR_2AffineMap_8cpp_source.html#l00058">mlirAffineMapMultiDimIdentityGet()</a>, and <a class="el" href="Tiling_8cpp_source.html#l00255">tileLinalgOpImpl()</a>.</p>

</div>
</div>
<a id="a75bef7af11cc1451c2e440718c5a5933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75bef7af11cc1451c2e440718c5a5933">&#9670;&nbsp;</a></span>getNumDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> AffineMap::getNumDims </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00295">295</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00577">addMemRefAccessConstraints()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00075">adjustMap()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00169">mlir::linalg::applyMapToValues()</a>, <a class="el" href="VectorToSCF_8cpp_source.html#l00045">applyMapToValues()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01664">augmentMapAndBounds()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01572">canonicalizeLoopBounds()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00428">compose()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00628">composeAffineMapAndOperands()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00539">mlir::FlatAffineConstraints::composeMatchingMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00519">mlir::compressDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00587">mlir::compressSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00538">mlir::compressUnusedDims()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00443">mlir::MemRefRegion::compute()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l00793">computeMemoryOpIndices()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00836">constructTiledIndexSetHyperRect()</a>, <a class="el" href="AffineToStandard_8cpp_source.html#l00223">mlir::expandAffineMap()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01976">foldExtractStridedOpFromInsertChain()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00058">getCleanupLoopLowerBound()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00488">getConstDifference()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00119">mlir::getFlattenedAffineExprs()</a>, <a class="el" href="AffineValueMap_8h_source.html#l00069">mlir::AffineValueMap::getNumDims()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00345">mlir::Builder::getShiftedAffineMap()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00690">mlir::getStridesAndOffset()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00643">mlir::inversePermutation()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00525">isFusableWithReshapeByDimExpansion()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00575">isIdentitySuffix()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01699">isRankReducedType()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00375">linearizeCollapsedDims()</a>, <a class="el" href="Loops_8cpp_source.html#l00036">makeCanonicalAffineApplies()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00595">mlir::linalg::AffineMinRangeCanonicalizationPattern::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02337">DeduplicateAffineMinMaxExpressions&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02380">MergeAffineMinMaxOp&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02974">TransferOpReduceRank::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l03124">CastAwayTransferReadLeadingOneDim::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l03167">CastAwayTransferWriteLeadingOneDim::matchAndRewrite()</a>, <a class="el" href="AffineLoopNormalize_8cpp_source.html#l00094">normalizeAffineFor()</a>, <a class="el" href="AffineLoopNormalize_8cpp_source.html#l00023">mlir::normalizeAffineParallel()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00195">mlir::detail::Parser::parseMemRefType()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01445">printBound()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l01681">printDenseElementsAttrImpl()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02913">printMinMaxBound()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00085">remainsLegalAfterInline()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00634">mlir::removeDuplicateExprs()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00030">mlir::replaceAllMemRefUsesWith()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00585">replaceDimOrSym()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00300">replaceUnitExtents()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00701">mlir::MutableAffineMap::reset()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00128">safeGetOrCreate()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00707">setInterTileBoundsParametric()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00612">setIntraTileBoundsParametric()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00563">mlir::MemRefType::Builder::setMemorySpace()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00624">mlir::simplifyAffineMap()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00512">substitute()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l02565">verify()</a>.</p>

</div>
</div>
<a id="aa821f07143bcad97d6df532c232129a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa821f07143bcad97d6df532c232129a3">&#9670;&nbsp;</a></span>getNumInputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> AffineMap::getNumInputs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00307">307</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00724">mlir::FlatAffineConstraints::addDomainFromSliceMaps()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02104">mlir::FlatAffineConstraints::addSliceBounds()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01572">canonicalizeLoopBounds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00539">mlir::FlatAffineConstraints::composeMatchingMap()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01173">mlir::AffineDmaWaitOp::fold()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02267">generatePointWiseCopy()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00263">generateShiftedLoop()</a>, <a class="el" href="AffineOps_8h_source.html#l00144">mlir::AffineDmaStartOp::getDstIndices()</a>, <a class="el" href="AffineOps_8h_source.html#l00117">mlir::AffineDmaStartOp::getDstMemRefOperandIndex()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00402">mlir::MemRefRegion::getLowerAndUpperBound()</a>, <a class="el" href="AffineOps_8h_source.html#l00105">mlir::AffineDmaStartOp::getSrcIndices()</a>, <a class="el" href="AffineOps_8h_source.html#l00173">mlir::AffineDmaStartOp::getTagIndices()</a>, <a class="el" href="AffineOps_8h_source.html#l00289">mlir::AffineDmaWaitOp::getTagIndices()</a>, <a class="el" href="AffineOps_8h_source.html#l00151">mlir::AffineDmaStartOp::getTagMemRefOperandIndex()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00643">mlir::inversePermutation()</a>, <a class="el" href="AffineOps_8h_source.html#l00231">mlir::AffineDmaStartOp::isStrided()</a>, <a class="el" href="Loops_8cpp_source.html#l00036">makeCanonicalAffineApplies()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01953">print()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01445">printBound()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00030">mlir::replaceAllMemRefUsesWith()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02139">verify()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02113">verifyMemoryOpIndexing()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00445">verifyOutputShape()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02226">verifyPermutationMap()</a>, and <a class="el" href="VectorOps_8cpp_source.html#l02254">verifyTransferOp()</a>.</p>

</div>
</div>
<a id="a96f194ae3b4baf33c67b10c9f795b564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f194ae3b4baf33c67b10c9f795b564">&#9670;&nbsp;</a></span>getNumResults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> AffineMap::getNumResults </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00303">303</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00724">mlir::FlatAffineConstraints::addDomainFromSliceMaps()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02013">mlir::FlatAffineConstraints::addLowerOrUpperBound()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00577">addMemRefAccessConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02104">mlir::FlatAffineConstraints::addSliceBounds()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00075">adjustMap()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00169">mlir::linalg::applyMapToValues()</a>, <a class="el" href="VectorToSCF_8cpp_source.html#l00045">applyMapToValues()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00030">areElementwiseOpsFusable()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00518">buildSliceTripCountMap()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01572">canonicalizeLoopBounds()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00428">compose()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00628">composeAffineMapAndOperands()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00539">mlir::FlatAffineConstraints::composeMatchingMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00519">mlir::compressDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00587">mlir::compressSymbols()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00836">constructTiledIndexSetHyperRect()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02685">mlir::vector::distributPointwiseVectorOp()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00124">mlir::ComputationSliceState::dump()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00960">foldExtractOpFromInsertChainAndTranspose()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00902">foldExtractOpFromTranspose()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01526">foldLoopBounds()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00802">fuseWithReshapeByExpansion()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00058">getCleanupLoopLowerBound()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00488">getConstDifference()</a>, <a class="el" href="Fusion_8cpp_source.html#l00539">getConsumerLoopToProducerLoopMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00119">mlir::getFlattenedAffineExprs()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00113">mlir::getLargestDivisorOfTripCount()</a>, <a class="el" href="AffineValueMap_8h_source.html#l00071">mlir::AffineValueMap::getNumResults()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00614">getResultIndex()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00345">mlir::Builder::getShiftedAffineMap()</a>, <a class="el" href="TensorDialect_8cpp_source.html#l00043">getSingletonDimLevelTypeVal()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01841">mlir::FlatAffineConstraints::getSliceBounds()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00430">initDependenceConstraints()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00643">mlir::inversePermutation()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00525">isFusableWithReshapeByDimExpansion()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00575">isIdentitySuffix()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01699">isRankReducedType()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00084">isTiled()</a>, <a class="el" href="Loops_8cpp_source.html#l00036">makeCanonicalAffineApplies()</a>, <a class="el" href="Tiling_8cpp_source.html#l00058">makeTiledLoopRanges()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00595">mlir::linalg::AffineMinRangeCanonicalizationPattern::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02337">DeduplicateAffineMinMaxExpressions&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00426">mlir::normalizeMemRefType()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00195">mlir::detail::Parser::parseMemRefType()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01209">populateFromInt64AttrArray()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01445">printBound()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00030">mlir::replaceAllMemRefUsesWith()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00585">replaceDimOrSym()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00707">setInterTileBoundsParametric()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00612">setIntraTileBoundsParametric()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00563">mlir::MemRefType::Builder::setMemorySpace()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02565">verify()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02113">verifyMemoryOpIndexing()</a>, and <a class="el" href="VectorOps_8cpp_source.html#l02254">verifyTransferOp()</a>.</p>

</div>
</div>
<a id="a750b299a4842c7965de35bd2cb1479a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a750b299a4842c7965de35bd2cb1479a0">&#9670;&nbsp;</a></span>getNumSymbols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> AffineMap::getNumSymbols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00299">299</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00577">addMemRefAccessConstraints()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00169">mlir::linalg::applyMapToValues()</a>, <a class="el" href="VectorToSCF_8cpp_source.html#l00045">applyMapToValues()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01664">augmentMapAndBounds()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01572">canonicalizeLoopBounds()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00428">compose()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00539">mlir::FlatAffineConstraints::composeMatchingMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00519">mlir::compressDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00587">mlir::compressSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00606">mlir::compressUnusedSymbols()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00443">mlir::MemRefRegion::compute()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l00793">computeMemoryOpIndices()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00836">constructTiledIndexSetHyperRect()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00058">getCleanupLoopLowerBound()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00488">getConstDifference()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00119">mlir::getFlattenedAffineExprs()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00652">getIndexingMapInExpandedOp()</a>, <a class="el" href="AffineValueMap_8h_source.html#l00070">mlir::AffineValueMap::getNumSymbols()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00345">mlir::Builder::getShiftedAffineMap()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00690">mlir::getStridesAndOffset()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00643">mlir::inversePermutation()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01699">isRankReducedType()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00375">linearizeCollapsedDims()</a>, <a class="el" href="Loops_8cpp_source.html#l00036">makeCanonicalAffineApplies()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00595">mlir::linalg::AffineMinRangeCanonicalizationPattern::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02337">DeduplicateAffineMinMaxExpressions&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02380">MergeAffineMinMaxOp&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l03124">CastAwayTransferReadLeadingOneDim::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l03167">CastAwayTransferWriteLeadingOneDim::matchAndRewrite()</a>, <a class="el" href="AffineLoopNormalize_8cpp_source.html#l00094">normalizeAffineFor()</a>, <a class="el" href="AffineLoopNormalize_8cpp_source.html#l00023">mlir::normalizeAffineParallel()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01445">printBound()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l01681">printDenseElementsAttrImpl()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00085">remainsLegalAfterInline()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00634">mlir::removeDuplicateExprs()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00030">mlir::replaceAllMemRefUsesWith()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00585">replaceDimOrSym()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00300">replaceUnitExtents()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00701">mlir::MutableAffineMap::reset()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00128">safeGetOrCreate()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00707">setInterTileBoundsParametric()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00612">setIntraTileBoundsParametric()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00624">mlir::simplifyAffineMap()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02565">verify()</a>, and <a class="el" href="VectorOps_8cpp_source.html#l02254">verifyTransferOp()</a>.</p>

</div>
</div>
<a id="acd08312b1039c20f008d2f6785c47816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd08312b1039c20f008d2f6785c47816">&#9670;&nbsp;</a></span>getPermutationMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::getPermutationMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td>
          <td class="paramname"><em>permutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a> representing a permutation. </p>
<p>The permutation is expressed as a non-empty vector of integers. E.g. the permutation <code>(i,j,k) -&gt; (j,k,i)</code> will be expressed with <code>permutation = [1,2,0]</code>. All values in <code>permutation</code> must be integers, in the range 0..<code>permutation.size()-1</code> without duplications (i.e. <code>[1,1,2]</code> is an invalid permutation). </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00205">205</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00957">get()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00482">mlir::getAffineDimExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8cpp_source.html#l00960">foldExtractOpFromInsertChainAndTranspose()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00902">foldExtractOpFromTranspose()</a>, <a class="el" href="Interchange_8cpp_source.html#l00052">mlir::linalg::interchange()</a>, <a class="el" href="Interchange_8cpp_source.html#l00035">mlir::linalg::interchangeGenericLinalgOpPrecondition()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02929">TransferReadPermutationLowering::matchAndRewrite()</a>, <a class="el" href="CAPI_2IR_2AffineMap_8cpp_source.html#l00068">mlirAffineMapPermutationGet()</a>, and <a class="el" href="Tiling_8cpp_source.html#l00255">tileLinalgOpImpl()</a>.</p>

</div>
</div>
<a id="ac60458b2cba87d765341cd6b2d41ed12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac60458b2cba87d765341cd6b2d41ed12">&#9670;&nbsp;</a></span>getResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> AffineMap::getResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00316">316</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00724">mlir::FlatAffineConstraints::addDomainFromSliceMaps()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02104">mlir::FlatAffineConstraints::addSliceBounds()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00169">mlir::linalg::applyMapToValues()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00124">mlir::ComputationSliceState::dump()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01976">foldExtractStridedOpFromInsertChain()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00058">getCleanupLoopLowerBound()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00488">getConstDifference()</a>, <a class="el" href="AffineValueMap_8h_source.html#l00067">mlir::AffineValueMap::getResult()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00614">getResultIndex()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00690">mlir::getStridesAndOffset()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00081">mlir::AffineValueMap::isFunctionOf()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01699">isRankReducedType()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00084">isTiled()</a>, <a class="el" href="AffineLoopNormalize_8cpp_source.html#l00094">normalizeAffineFor()</a>, <a class="el" href="AffineLoopNormalize_8cpp_source.html#l00023">mlir::normalizeAffineParallel()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01209">populateFromInt64AttrArray()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01445">printBound()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l02913">printMinMaxBound()</a>.</p>

</div>
</div>
<a id="a79007ce78cfccb064390c22a4af6037c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79007ce78cfccb064390c22a4af6037c">&#9670;&nbsp;</a></span>getResults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; AffineMap::getResults </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00312">312</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgInterfaces_8cpp_source.html#l00169">mlir::linalg::applyMapToValues()</a>, <a class="el" href="VectorToSCF_8cpp_source.html#l00045">applyMapToValues()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01664">augmentMapAndBounds()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00840">mlir::AffineExpr::compose()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00519">mlir::compressDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00587">mlir::compressSymbols()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l00793">computeMemoryOpIndices()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00836">constructTiledIndexSetHyperRect()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02685">mlir::vector::distributPointwiseVectorOp()</a>, <a class="el" href="Fusion_8cpp_source.html#l00581">doesTransposeAccess()</a>, <a class="el" href="AffineToStandard_8cpp_source.html#l00223">mlir::expandAffineMap()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00902">foldExtractOpFromTranspose()</a>, <a class="el" href="Fusion_8cpp_source.html#l00239">fuse()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01372">getCollapsedOutputDimFromInputShape()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00087">mlir::getConstantTripCount()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00670">getExpandedType()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00119">mlir::getFlattenedAffineExprs()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00652">getIndexingMapInExpandedOp()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00113">mlir::getLargestDivisorOfTripCount()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00688">getReassociationForExpansion()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00345">mlir::Builder::getShiftedAffineMap()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01994">inferTransposeResultType()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00643">mlir::inversePermutation()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00525">isFusableWithReshapeByDimExpansion()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00575">isIdentitySuffix()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00375">linearizeCollapsedDims()</a>, <a class="el" href="Loops_8cpp_source.html#l00036">makeCanonicalAffineApplies()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00595">mlir::linalg::AffineMinRangeCanonicalizationPattern::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02337">DeduplicateAffineMinMaxExpressions&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02380">MergeAffineMinMaxOp&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02974">TransferOpReduceRank::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l03124">CastAwayTransferReadLeadingOneDim::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l03167">CastAwayTransferWriteLeadingOneDim::matchAndRewrite()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00694">mlir::MutableAffineMap::MutableAffineMap()</a>, <a class="el" href="AffineLoopNormalize_8cpp_source.html#l00094">normalizeAffineFor()</a>, <a class="el" href="AffineLoopNormalize_8cpp_source.html#l00023">mlir::normalizeAffineParallel()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l01179">mlir::MemRefAccess::operator==()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l01681">printDenseElementsAttrImpl()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00634">mlir::removeDuplicateExprs()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00030">mlir::replaceAllMemRefUsesWith()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00183">replaceBlockArgForUnitDimLoops&lt; IndexedGenericOp &gt;()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00300">replaceUnitExtents()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00701">mlir::MutableAffineMap::reset()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00128">safeGetOrCreate()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00707">setInterTileBoundsParametric()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00612">setIntraTileBoundsParametric()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00624">mlir::simplifyAffineMap()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00512">substitute()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02565">verify()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02226">verifyPermutationMap()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00314">mlir::linalg::detail::verifyStructuredOpInterface()</a>, and <a class="el" href="LinalgInterfaces_8cpp_source.html#l00254">HasAffineDimExprVisitor::visitSymbolExpr()</a>.</p>

</div>
</div>
<a id="a029344fc35377bfa5b59b51edaf304d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a029344fc35377bfa5b59b51edaf304d9">&#9670;&nbsp;</a></span>getSingleConstantResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t AffineMap::getSingleConstantResult </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the constant result of this map. </p>
<p>This methods asserts that the map has a single constant result. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00290">290</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

</div>
</div>
<a id="a054f395f1fc7a1db524caa616e460bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a054f395f1fc7a1db524caa616e460bed">&#9670;&nbsp;</a></span>getSliceMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::getSliceMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the map consisting of <code>length</code> expressions starting from <code>start</code>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00497">497</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00957">get()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l02913">printMinMaxBound()</a>.</p>

</div>
</div>
<a id="add23e0ad557890ca7113d38e96c4c870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add23e0ad557890ca7113d38e96c4c870">&#9670;&nbsp;</a></span>getSubMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::getSubMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td>
          <td class="paramname"><em>resultPos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the map consisting of the <code>resultPos</code> subset. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00489">489</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00957">get()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FusionOnTensors_8cpp_source.html#l00098">generateFusedElementwiseOpRegion()</a>, <a class="el" href="Interchange_8cpp_source.html#l00052">mlir::linalg::interchange()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00488">mlir::linalg::makeTiledShapes()</a>, and <a class="el" href="LinalgInterfaces_8cpp_source.html#l00254">HasAffineDimExprVisitor::visitSymbolExpr()</a>.</p>

</div>
</div>
<a id="aadfe536e16fe5c891a482d816cd33ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadfe536e16fe5c891a482d816cd33ede">&#9670;&nbsp;</a></span>inferFromExprList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>, 4 &gt; AffineMap::inferFromExprList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>exprsList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector of AffineMaps; each with as many results as <code>exprs.size()</code>, as many dims as the largest dim in <code>exprs</code> and as many symbols as the largest symbol in <code>exprs</code>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00250">250</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00235">inferFromExprList()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorTransforms_8cpp_source.html#l02399">createScopedSubViewIntersection()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00882">mlir::makeCanonicalStridedLayoutExpr()</a>, <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8cpp_source.html#l00025">mlir::edsc::makeGenericLinalgOp()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01866">mlir::ContractionOpToOuterProductOpLowering::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01980">mlir::ContractionOpToDotLowering::matchAndRewrite()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00329">print()</a>, and <a class="el" href="TosaToLinalg_8cpp_source.html#l00647">reduceMatchAndRewriteHelper()</a>.</p>

</div>
</div>
<a id="a2d944ece09b92ecacf206d2f377fa99f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d944ece09b92ecacf206d2f377fa99f">&#9670;&nbsp;</a></span>inferFromExprList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>, 4 &gt; AffineMap::inferFromExprList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 4 &gt;&gt;&#160;</td>
          <td class="paramname"><em>exprsList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00255">255</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00235">inferFromExprList()</a>.</p>

</div>
</div>
<a id="a5752e3927fef1c67c276e3aa956e9cfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5752e3927fef1c67c276e3aa956e9cfe">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AffineMap::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this affine map is an empty map, i.e., () -&gt; (). </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00282">282</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Interchange_8cpp_source.html#l00052">mlir::linalg::interchange()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00643">mlir::inversePermutation()</a>, and <a class="el" href="Loops_8cpp_source.html#l00036">makeCanonicalAffineApplies()</a>.</p>

</div>
</div>
<a id="a173d3fd01950f75a2285a872b22e2c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173d3fd01950f75a2285a872b22e2c48">&#9670;&nbsp;</a></span>isFunctionOfDim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::AffineMap::isFunctionOfDim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if any affine expression involves <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression. ">AffineDimExpr</a> <code>position</code>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8h_source.html#l00159">159</a> of file <a class="el" href="IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00271">mlir::AffineExpr::isFunctionOfDim()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00628">composeAffineMapAndOperands()</a>.</p>

</div>
</div>
<a id="a7df13ef25920c15d07c7bc9686b26be7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7df13ef25920c15d07c7bc9686b26be7">&#9670;&nbsp;</a></span>isFunctionOfSymbol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::AffineMap::isFunctionOfSymbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if any affine expression involves <a class="el" href="classmlir_1_1AffineSymbolExpr.html" title="A symbolic identifier appearing in an affine expression. ">AffineSymbolExpr</a> <code>position</code>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8h_source.html#l00166">166</a> of file <a class="el" href="IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00282">mlir::AffineExpr::isFunctionOfSymbol()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00628">composeAffineMapAndOperands()</a>.</p>

</div>
</div>
<a id="af33ea095c58804447510ad5ff023975c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af33ea095c58804447510ad5ff023975c">&#9670;&nbsp;</a></span>isIdentity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AffineMap::isIdentity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this affine map is an identity affine map. </p>
<p>An identity affine map corresponds to an identity affine function on the dimensional identifiers. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00270">270</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8cpp_source.html#l00960">foldExtractOpFromInsertChainAndTranspose()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00690">mlir::getStridesAndOffset()</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02929">TransferReadPermutationLowering::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a1ccbe714fa69ce8426190f88b7854a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ccbe714fa69ce8426190f88b7854a98">&#9670;&nbsp;</a></span>isMinorIdentity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AffineMap::isMinorIdentity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this affine map is a minor identity, i.e. </p>
<p>an identity affine map (d0, ..., dn) -&gt; (dp, ..., dn) on the most minor dimensions. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00109">109</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8cpp_source.html#l00960">foldExtractOpFromInsertChainAndTranspose()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00902">foldExtractOpFromTranspose()</a>, and <a class="el" href="VectorOps_8cpp_source.html#l02548">foldTransferInBoundsAttribute()</a>.</p>

</div>
</div>
<a id="a753daf697958f1aa999c10c163d3c35b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a753daf697958f1aa999c10c163d3c35b">&#9670;&nbsp;</a></span>isMinorIdentityWithBroadcasting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AffineMap::isMinorIdentityWithBroadcasting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; *&#160;</td>
          <td class="paramname"><em>broadcastedDims</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this affine map is a minor identity up to broadcasted dimensions which are indicated by value 0 in the result. </p>
<p>If <code>broadcastedDims</code> is not null, it will be populated with the indices of the broadcasted dimensions in the result array. Example: affine_map&lt;(d0, d1, d2, d3, d4) -&gt; (0, d2, 0, d4)&gt; (<code>broadcastedDims</code> will contain [0, 2])</p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00117">117</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8h_source.html#l00276">mlir::AffineExpr::dyn_cast()</a>, and <a class="el" href="Matchers_8h_source.html#l00196">mlir::detail::enumerate()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorTransforms_8cpp_source.html#l02974">TransferOpReduceRank::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="af6e665372add0df0668e1ebd231488b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6e665372add0df0668e1ebd231488b4">&#9670;&nbsp;</a></span>isPermutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AffineMap::isPermutation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a> represents a symbol-less permutation map. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00483">483</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="FusionOnTensors_8cpp_source.html#l00030">areElementwiseOpsFusable()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00960">foldExtractOpFromInsertChainAndTranspose()</a>, <a class="el" href="Fusion_8cpp_source.html#l00539">getConsumerLoopToProducerLoopMap()</a>, <a class="el" href="TensorDialect_8cpp_source.html#l00043">getSingletonDimLevelTypeVal()</a>, and <a class="el" href="FusionOnTensors_8cpp_source.html#l00412">isTensorReshapeOpFoldableByLinearization()</a>.</p>

</div>
</div>
<a id="a819c4c0117656eae56b72348e469c01e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819c4c0117656eae56b72348e469c01e">&#9670;&nbsp;</a></span>isPermutationOfMinorIdentityWithBroadcasting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AffineMap::isPermutationOfMinorIdentityWithBroadcasting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>permutedDims</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this affine map can be converted to a minor identity with broadcast by doing a permute. </p>
<p>Return a permutation (there may be several) to apply to get to a minor identity with broadcasts. Ex:</p><ul>
<li>(d0, d1, d2) -&gt; (0, d1) maps to minor identity (d1, 0 = d2) with perm = [1, 0] and broadcast d2</li>
<li>(d0, d1, d2) -&gt; (d0, 0) cannot be mapped to a minor identity by permutation + broadcast</li>
<li>(d0, d1, d2, d3) -&gt; (0, d1, d3) maps to minor identity (d1, 0 = d2, d3) with perm = [1, 0, 2] and broadcast d2</li>
<li>(d0, d1) -&gt; (d1, 0, 0, d0) maps to minor identity (d0, d1) with extra leading broadcat dimensions. The map returned would be (0, 0, d0, d1) with perm = [3, 0, 1, 2] </li>
</ul>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00157">157</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8h_source.html#l00276">mlir::AffineExpr::dyn_cast()</a>, <a class="el" href="Matchers_8h_source.html#l00196">mlir::detail::enumerate()</a>, and <a class="el" href="PolynomialApproximation_8cpp_source.html#l00111">max()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorTransforms_8cpp_source.html#l02929">TransferReadPermutationLowering::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a197911eedb042527da82f693725fa041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a197911eedb042527da82f693725fa041">&#9670;&nbsp;</a></span>isProjectedPermutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AffineMap::isProjectedPermutation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a> represents a subset (i.e. </p>
<p>a projection) of a symbol-less permutation map. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00467">467</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8h_source.html#l00276">mlir::AffineExpr::dyn_cast()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgInterfaces_8cpp_source.html#l00099">isContractionInterfaceImpl()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01209">populateFromInt64AttrArray()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00076">reindexIndexingMap()</a>.</p>

</div>
</div>
<a id="a4197b91018d6d6badaccdcb0ce6c1e12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4197b91018d6d6badaccdcb0ce6c1e12">&#9670;&nbsp;</a></span>isSingleConstant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AffineMap::isSingleConstant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this affine map is a single result constant function. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00286">286</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01572">canonicalizeLoopBounds()</a>.</p>

</div>
</div>
<a id="a4db87d862458ead8c492e1a05ce18e33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4db87d862458ead8c492e1a05ce18e33">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::AffineMap::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8h_source.html#l00094">94</a> of file <a class="el" href="IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

</div>
</div>
<a id="ad066a62bd10ed01423748bdd913565be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad066a62bd10ed01423748bdd913565be">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::AffineMap::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8h_source.html#l00096">96</a> of file <a class="el" href="IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Shape_2IR_2Shape_8cpp_source.html#l00984">print()</a>.</p>

</div>
</div>
<a id="a7381857cac60752009640964e99172c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7381857cac60752009640964e99172c2">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::AffineMap::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8h_source.html#l00095">95</a> of file <a class="el" href="IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

</div>
</div>
<a id="a17616a46809bbfc6a46d16186817201d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17616a46809bbfc6a46d16186817201d">&#9670;&nbsp;</a></span>partialConstantFold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::partialConstantFold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>operandConstants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *&#160;</td>
          <td class="paramname"><em>results</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Propagates the constant operands into this affine map. </p>
<p>Operands are allowed to be null, at which point they are treated as non-constant. This does not change the number of symbols and dimensions. Returns a new map, which may be equal to the old map if no folding happened. If <code>results</code> is provided and if all expressions in the map were folded to constants, <code>results</code> will contain the values of these constants. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00348">348</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00507">mlir::getAffineConstantExpr()</a>.</p>

</div>
</div>
<a id="ae0ecd6ef18c3c3fa94c053f5fba67bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ecd6ef18c3c3fa94c053f5fba67bdf">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> AffineMap::print </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsmPrinter_8cpp_source.html#l02652">2652</a> of file <a class="el" href="AsmPrinter_8cpp_source.html">AsmPrinter.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00539">getConsumerLoopToProducerLoopMap()</a>, and <a class="el" href="IR_2AffineMap_8h_source.html#l00452">mlir::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a id="ac7d5c7e20f021aac37fcb4e65cbfca8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d5c7e20f021aac37fcb4e65cbfca8c">&#9670;&nbsp;</a></span>replace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numResultDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numResultSyms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sparse replace method. </p>
<p>Apply <a class="el" href="classmlir_1_1AffineExpr.html#ac62de85207ad0444e6f82d4e74595e79" title="Sparse replace method. ">AffineExpr::replace</a>(<code>expr</code>, <code>replacement</code>) to each of the results and return a new <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a> with the new results and with the specified number of dims and symbols. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00405">405</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00957">get()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00585">replaceDimOrSym()</a>.</p>

</div>
</div>
<a id="a4822614b5ae9d1f80e0b3da7b3ce664d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4822614b5ae9d1f80e0b3da7b3ce664d">&#9670;&nbsp;</a></span>replace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::replace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numResultDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numResultSyms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sparse replace method. </p>
<p>Apply <a class="el" href="classmlir_1_1AffineExpr.html#ac62de85207ad0444e6f82d4e74595e79" title="Sparse replace method. ">AffineExpr::replace</a>(<code>map</code>) to each of the results and return a new <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a> with the new results and with the specified number of dims and symbols. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00418">418</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00957">get()</a>.</p>

</div>
</div>
<a id="aa1fdca78f9d7bde157d251892dd99fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1fdca78f9d7bde157d251892dd99fa8">&#9670;&nbsp;</a></span>replaceDimsAndSymbols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::replaceDimsAndSymbols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>dimReplacements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>symReplacements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numResultDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numResultSyms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method substitutes any uses of dimensions and symbols (e.g. </p>
<p>dim#0 with dimReplacements[0]) in subexpressions and returns the modified expression mapping. Because this can be used to eliminate dims and symbols, the client needs to specify the number of dims and symbols in the result. The returned map always has the same number of results. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">390</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00062">mlir::AffineExpr::replaceDimsAndSymbols()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8cpp_source.html#l00428">compose()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00628">composeAffineMapAndOperands()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l03025">parseAffineMapWithMinMax()</a>.</p>

</div>
</div>
<a id="a10ba29799ec6508e4de245202dec38e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10ba29799ec6508e4de245202dec38e8">&#9670;&nbsp;</a></span>shiftDims()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::AffineMap::shiftDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>shift</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace dims[0 .. numDims - 1] by dims[shift .. shift + numDims - 1]. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8h_source.html#l00199">199</a> of file <a class="el" href="IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00957">get()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00105">mlir::AffineExpr::shiftDims()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineValueMap_8cpp_source.html#l00026">mlir::AffineValueMap::difference()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00585">replaceDimOrSym()</a>.</p>

</div>
</div>
<a id="aeaac1516f0672a778670fb435a4ddc4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaac1516f0672a778670fb435a4ddc4a">&#9670;&nbsp;</a></span>shiftSymbols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::AffineMap::shiftSymbols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>shift</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace symbols[0 . </p>
<p>. numSymbols - 1] by symbols[shift .. shift + numSymbols - 1]. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8h_source.html#l00210">210</a> of file <a class="el" href="IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00957">get()</a>, <a class="el" href="IR_2AffineExpr_8h_source.html#l00235">mlir::hash_value()</a>, <a class="el" href="IRAffine_8cpp_source.html#l00054">isPermutation()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00114">mlir::AffineExpr::shiftSymbols()</a>.</p>

</div>
</div>
<a id="a113361b495944795b99c988b9f658702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a113361b495944795b99c988b9f658702">&#9670;&nbsp;</a></span>walkExprs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> AffineMap::walkExprs </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>)&gt;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk all of the <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a>'s in this mapping. </p>
<p>Each node in an expression tree is visited in postorder. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00380">380</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00026">mlir::AffineExpr::walk()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8cpp_source.html#l00538">mlir::compressUnusedDims()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00606">mlir::compressUnusedSymbols()</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a07dc7e1df4f0d9e9c4d1038f7a688527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07dc7e1df4f0d9e9c4d1038f7a688527">&#9670;&nbsp;</a></span>hash_value</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">::llvm::hash_code hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8h_source.html#l00296">296</a> of file <a class="el" href="IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/IR/<a class="el" href="IR_2AffineMap_8h_source.html">AffineMap.h</a></li>
<li>lib/IR/<a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a></li>
<li>lib/IR/<a class="el" href="AsmPrinter_8cpp_source.html">AsmPrinter.cpp</a></li>
<li>lib/IR/<a class="el" href="MLIRContext_8cpp_source.html">MLIRContext.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Apr 30 2021 08:50:55 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
