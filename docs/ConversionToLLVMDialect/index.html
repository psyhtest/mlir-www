<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Conversion to the LLVM Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.80.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/ConversionToLLVMDialect/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><script type=text/javascript src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li></ul></nav></div><div class=content-container><main><h1>Conversion to the LLVM Dialect</h1><p>Conversion from several dialects that rely on
<a href=/docs/LangRef/>built-in types</a>
to the
<a href=/docs/Dialects/LLVM/>LLVM Dialect</a>
is expected to be performed through the
<a href=/docs/DialectConversion/>Dialect Conversion</a>
infrastructure.</p><p>The conversion of types and that of the overall module structure is described in
this document. Individual conversion passes provide a set of conversion patterns
for ops in different dialects, such as <code>-convert-std-to-llvm</code> for ops in the
<a href=/docs/Dialects/Standard/>Standard dialect</a>
and <code>-convert-vector-to-llvm</code> in the
<a href=/docs/Dialects/Vector/>Vector dialect</a>
. <em>Note that some conversions subsume the
others.</em></p><p>We use the terminology defined by the
<a href=/docs/Dialects/LLVM/>LLVM Dialect description</a>
throughout this document.</p><p><nav id=TableOfContents><ul><li><a href=#type-conversion>Type Conversion</a><ul><li><a href=#scalar-types>Scalar Types</a></li><li><a href=#index-type>Index Type</a></li><li><a href=#vector-types>Vector Types</a></li><li><a href=#ranked-memref-types>Ranked Memref Types</a></li><li><a href=#unranked-memref-types>Unranked Memref types</a></li><li><a href=#function-types>Function Types</a></li></ul></li></ul></nav><h2 id=type-conversion>Type Conversion&nbsp;<a class=headline-hash href=#type-conversion>¶</a></h2><h3 id=scalar-types>Scalar Types&nbsp;<a class=headline-hash href=#scalar-types>¶</a></h3><p>Scalar types are converted to their LLVM counterparts if they exist. The
following conversions are currently implemented:</p><ul><li><code>i*</code> converts to <code>!llvm.i*</code></li><li><code>bf16</code> converts to <code>bf16</code></li><li><code>f16</code> converts to <code>f16</code></li><li><code>f32</code> converts to <code>f32</code></li><li><code>f64</code> converts to <code>f64</code></li><li><code>f80</code> converts to <code>f80</code></li><li><code>f128</code> converts to <code>f128</code></li></ul><h3 id=index-type>Index Type&nbsp;<a class=headline-hash href=#index-type>¶</a></h3><p>Index type is converted to an LLVM dialect integer type with bitwidth equal to
the bitwidth of the pointer size as specified by the
<a href=/docs/Dialects/LLVM/>data layout</a>
of the closest module.
For example, on x86-64 CPUs it converts to <code>i64</code>. This behavior can be
overridden by the type converter configuration, which is often exposed as a pass
option by conversion passes.</p><h3 id=vector-types>Vector Types&nbsp;<a class=headline-hash href=#vector-types>¶</a></h3><p>LLVM IR only supports <em>one-dimensional</em> vectors, unlike MLIR where vectors can
be multi-dimensional. Vector types cannot be nested in either IR. In the
one-dimensional case, MLIR vectors are converted to LLVM IR vectors of the same
size with element type converted using these conversion rules. In the
n-dimensional case, MLIR vectors are converted to (n-1)-dimensional array types
of one-dimensional vectors.</p><p>For example, <code>vector&lt;4xf32></code> converts to <code>vector&lt;4xf32></code> and <code>vector&lt;4 x 8 x 16 x f32></code> converts to <code>!llvm.array&lt;4 x array&lt;8 x vec&lt;16 x f32>>></code>.</p><h3 id=ranked-memref-types>Ranked Memref Types&nbsp;<a class=headline-hash href=#ranked-memref-types>¶</a></h3><p>Memref types in MLIR have both static and dynamic information associated with
them. In the general case, the dynamic information describes dynamic sizes in
the logical indexing space and any symbols bound to the memref. This dynamic
information must be present at runtime in the LLVM dialect equivalent type.</p><p>In practice, the conversion supports two conventions:</p><ul><li>the default convention for memrefs in the
<strong><a href=/docs/LangRef/>strided form</a>
</strong>;</li><li>a &ldquo;bare pointer&rdquo; conversion for statically-shaped memrefs with default
layout.</li></ul><p>The choice between conventions is specified at type converter construction time
and is often exposed as an option by conversion passes.</p><p>Memrefs with arbitrary layouts are not supported. Instead, these layouts can be
factored out of the type and used as part of index computation for operations
that read and write into a memref with the default layout.</p><h4 id=default-convention>Default Convention&nbsp;<a class=headline-hash href=#default-convention>¶</a></h4><p>The dynamic information comprises the buffer pointer as well as sizes and
strides of any dynamically-sized dimensions. Memref types are normalized and
converted to a <em>descriptor</em> that is only dependent on the rank of the memref.
The descriptor contains the following fields in order:</p><ol><li>The pointer to the data buffer as allocated, referred to as &ldquo;allocated
pointer&rdquo;. This is only useful for deallocating the memref.</li><li>The pointer to the properly aligned data pointer that the memref indexes,
referred to as &ldquo;aligned pointer&rdquo;.</li><li>A lowered converted <code>index</code>-type integer containing the distance in number
of elements between the beginning of the (aligned) buffer and the first
element to be accessed through the memref, referred to as &ldquo;offset&rdquo;.</li><li>An array containing as many converted <code>index</code>-type integers as the rank of
the memref: the array represents the size, in number of elements, of the
memref along the given dimension. For constant memref dimensions, the
corresponding size entry is a constant whose runtime value must match the
static value.</li><li>A second array containing as many converted <code>index</code>-type integers as the
rank of memref: the second array represents the &ldquo;stride&rdquo; (in tensor
abstraction sense), i.e. the number of consecutive elements of the
underlying buffer one needs to jump over to get to the next logically
indexed element.</li></ol><p>For constant memref dimensions, the corresponding size entry is a constant whose
runtime value matches the static value. This normalization serves as an ABI for
the memref type to interoperate with externally linked functions. In the
particular case of rank <code>0</code> memrefs, the size and stride arrays are omitted,
resulting in a struct containing two pointers + offset.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>memref</span><span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>.</span>struct<span class=p>&lt;(</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>,</span> ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=k>i64</span><span class=p>)&gt;</span>
<span class=kt>memref</span><span class=p>&lt;</span><span class=m>1 x</span> <span class=k>f32</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>.</span>struct<span class=p>&lt;(</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;,</span> ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=k>i64</span><span class=p>,</span>
                                 array<span class=p>&lt;</span><span class=m>1 x</span> <span class=m>64</span><span class=p>&gt;,</span> array<span class=p>&lt;</span><span class=m>1 x</span> <span class=k>i64</span><span class=p>&gt;)&gt;</span>
<span class=kt>memref</span><span class=p>&lt;</span><span class=m>? x</span> <span class=k>f32</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>.</span>struct<span class=p>&lt;(</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;,</span> ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=k>i64</span>
                                 array<span class=p>&lt;</span><span class=m>1 x</span> <span class=m>64</span><span class=p>&gt;,</span> array<span class=p>&lt;</span><span class=m>1 x</span> <span class=k>i64</span><span class=p>&gt;)&gt;</span>
<span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x42x42x43x123 x</span> <span class=k>f32</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>.</span>struct<span class=p>&lt;(</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;,</span> ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=k>i64</span>
                                               array<span class=p>&lt;</span><span class=m>5 x</span> <span class=m>64</span><span class=p>&gt;,</span> array<span class=p>&lt;</span><span class=m>5 x</span> <span class=k>i64</span><span class=p>&gt;)&gt;</span>
<span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x?x42x?x123 x</span> <span class=k>f32</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>.</span>struct<span class=p>&lt;(</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;,</span> ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=k>i64</span>
                                             array<span class=p>&lt;</span><span class=m>5 x</span> <span class=m>64</span><span class=p>&gt;,</span> array<span class=p>&lt;</span><span class=m>5 x</span> <span class=k>i64</span><span class=p>&gt;)&gt;</span>

<span class=c>// Memref types can have vectors as element types
</span><span class=c></span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>1x? x</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;&gt;</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>.</span>struct<span class=p>&lt;(</span>ptr<span class=p>&lt;</span>vec<span class=p>&lt;</span><span class=m>4 x</span> <span class=k>f32</span><span class=p>&gt;&gt;,</span>
                                             ptr<span class=p>&lt;</span>vec<span class=p>&lt;</span><span class=m>4 x</span> float<span class=p>&gt;&gt;,</span> <span class=k>i64</span><span class=p>,</span>
                                             array<span class=p>&lt;</span><span class=m>1 x</span> <span class=k>i64</span><span class=p>&gt;,</span> array<span class=p>&lt;</span><span class=m>1 x</span> <span class=k>i64</span><span class=p>&gt;)&gt;</span>
</code></pre></div><h4 id=bare-pointer-convention>Bare Pointer Convention&nbsp;<a class=headline-hash href=#bare-pointer-convention>¶</a></h4><p>Ranked memrefs with static shape and default layout can be converted into an
LLVM dialect pointer to their element type. Only the default alignment is
supported in such cases, e.g. the <code>alloc</code> operation cannot have an alignment
attribute.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>memref</span><span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x42 x</span> <span class=k>f32</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Memrefs with vector types are also supported.
</span><span class=c></span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x42 x</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;&gt;</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>&lt;</span>vec<span class=p>&lt;</span><span class=m>4 x</span> <span class=k>f32</span><span class=p>&gt;&gt;</span>
</code></pre></div><h3 id=unranked-memref-types>Unranked Memref types&nbsp;<a class=headline-hash href=#unranked-memref-types>¶</a></h3><p>Unranked memrefs are converted to an unranked descriptor that contains:</p><ol><li>a converted <code>index</code>-typed integer representing the dynamic rank of the
memref;</li><li>a type-erased pointer (<code>!llvm.ptr&lt;i8></code>) to a ranked memref descriptor with
the contents listed above.</li></ol><p>This descriptor is primarily intended for interfacing with rank-polymorphic
library functions. The pointer to the ranked memref descriptor points to memory
<em>allocated on stack</em> of the function in which it is used.</p><p>Note that stack allocations may be emitted at a location where the unranked
memref first appears, e.g., a cast operation, and remain live throughout the
lifetime of the function; this may lead to stack exhaustion if used in a loop.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Unranked descriptor.
</span><span class=c></span><span class=kt>memref</span><span class=p>&lt;*</span>xf32<span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>.</span>struct<span class=p>&lt;(</span><span class=k>i64</span><span class=p>,</span> ptr<span class=p>&lt;</span><span class=k>i8</span><span class=p>&gt;)&gt;</span>
</code></pre></div><p>Bare pointer convention does not support unranked memrefs.</p><h3 id=function-types>Function Types&nbsp;<a class=headline-hash href=#function-types>¶</a></h3><p>Function types get converted to LLVM dialect function types. The arguments are
converted individually according to these rules, except for <code>memref</code> types in
function arguments and high-order functions, which are described below. The
result types need to accommodate the fact that LLVM functions always have a
return type, which may be an <code>!llvm.void</code> type. The converted function always
has a single result type. If the original function type had no results, the
converted function will have one result of the <code>!llvm.void</code> type. If the
original function type had one result, the converted function will also have one
result converted using these rules. Otherwise, the result type will be an LLVM
dialect structure type where each element of the structure corresponds to one of
the results of the original function, converted using these rules.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Zero-ary function type with no results:
</span><span class=c></span><span class=p>()</span> <span class=p>-&gt;</span> <span class=p>()</span>
<span class=c>// is converted to a zero-ary function with `void` result.
</span><span class=c></span><span class=p>!</span>llvm<span class=p>.</span><span class=kt>func</span><span class=p>&lt;</span>void <span class=p>()&gt;</span>

<span class=c>// Unary function with one result:
</span><span class=c></span><span class=p>(</span><span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>i64</span><span class=p>)</span>
<span class=c>// has its argument and result type converted, before creating the LLVM dialect
</span><span class=c>// function type.
</span><span class=c></span><span class=p>!</span>llvm<span class=p>.</span><span class=kt>func</span><span class=p>&lt;</span><span class=k>i64</span> <span class=p>(</span><span class=k>i32</span><span class=p>)&gt;</span>

<span class=c>// Binary function with one result:
</span><span class=c></span><span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>i64</span><span class=p>)</span>
<span class=c>// has its arguments handled separately
</span><span class=c></span><span class=p>!</span>llvm<span class=p>.</span><span class=kt>func</span><span class=p>&lt;</span><span class=k>i64</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>f32</span><span class=p>)&gt;</span>

<span class=c>// Binary function with two results:
</span><span class=c></span><span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>i64</span><span class=p>,</span> <span class=k>f64</span><span class=p>)</span>
<span class=c>// has its result aggregated into a structure type.
</span><span class=c></span><span class=p>!</span>llvm<span class=p>.</span><span class=kt>func</span><span class=p>&lt;</span>struct<span class=p>&lt;(</span><span class=k>i64</span><span class=p>,</span> <span class=k>f64</span><span class=p>)&gt;</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>f32</span><span class=p>)&gt;</span>
</code></pre></div><h4 id=functions-as-function-arguments-or-results>Functions as Function Arguments or Results&nbsp;<a class=headline-hash href=#functions-as-function-arguments-or-results>¶</a></h4><p>High-order function types, i.e. types of functions that have other functions as
arguments or results, are converted differently to accommodate the fact that
LLVM IR does not allow for function-typed values. Instead, functions are
expected to be passed into and return from other functions <em>by pointer</em>.
Therefore, function-typed function arguments are results are converted to
pointer-to-the-function type. The pointee type is converted using these rules.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Function-typed arguments or results in higher-order functions:
</span><span class=c></span><span class=p>(()</span> <span class=p>-&gt;</span> <span class=p>())</span> <span class=p>-&gt;</span> <span class=p>(()</span> <span class=p>-&gt;</span> <span class=p>())</span>
<span class=c>// are converted into pointers to functions.
</span><span class=c></span><span class=p>!</span>llvm<span class=p>.</span><span class=kt>func</span><span class=p>&lt;</span>ptr<span class=p>&lt;</span><span class=kt>func</span><span class=p>&lt;</span>void <span class=p>()&gt;&gt;</span> <span class=p>(</span>ptr<span class=p>&lt;</span><span class=kt>func</span><span class=p>&lt;</span>void <span class=p>()&gt;&gt;)&gt;</span>

<span class=c>// These rules apply recursively: a function type taking a function that takes
</span><span class=c>// another function
</span><span class=c></span><span class=p>(</span> <span class=p>(</span> <span class=p>(</span><span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>i64</span><span class=p>)</span> <span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span> <span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span>
<span class=c>// is converted into a function type taking a pointer-to-function that takes
</span><span class=c>// another point-to-function.
</span><span class=c></span><span class=p>!</span>llvm<span class=p>.</span><span class=kt>func</span><span class=p>&lt;</span>void <span class=p>(</span>ptr<span class=p>&lt;</span><span class=kt>func</span><span class=p>&lt;</span>void <span class=p>(</span>ptr<span class=p>&lt;</span><span class=kt>func</span><span class=p>&lt;</span><span class=k>i64</span> <span class=p>(</span><span class=k>i32</span><span class=p>)&gt;&gt;)&gt;&gt;)&gt;</span>
</code></pre></div><h4 id=memrefs-as-function-arguments>Memrefs as Function Arguments&nbsp;<a class=headline-hash href=#memrefs-as-function-arguments>¶</a></h4><p>When used as function arguments, both ranked and unranked memrefs are converted
into a list of arguments that represents each <em>scalar</em> component of their
descriptor. This is intended for some compatibility with C ABI, in which
structure types would need to be passed by-pointer leading to the need for
allocations and related issues, as well as for aliasing annotations, which are
currently attached to pointer in function arguments. Having scalar components
means that each size and stride is passed as an individual value.</p><p>When used as function results, memrefs are converted as usual, i.e. each memref
is converted to a descriptor struct (default convention) or to a pointer (bare
pointer convention).</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// A memref descriptor appearing as function argument:
</span><span class=c></span><span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>()</span>
<span class=c>// gets converted into a list of individual scalar components of a descriptor.
</span><span class=c></span><span class=p>!</span>llvm<span class=p>.</span><span class=kt>func</span><span class=p>&lt;</span>void <span class=p>(</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;,</span> ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=k>i64</span><span class=p>)&gt;</span>

<span class=c>// The list of arguments is linearized and one can freely mix memref and other
</span><span class=c>// types in this list:
</span><span class=c></span><span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span>
<span class=c>// which gets converted into a flat list.
</span><span class=c></span><span class=p>!</span>llvm<span class=p>.</span><span class=kt>func</span><span class=p>&lt;</span>void <span class=p>(</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;,</span> ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=k>i64</span><span class=p>,</span> <span class=k>f32</span><span class=p>)&gt;</span>

<span class=c>// For nD ranked memref descriptors:
</span><span class=c></span><span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>()</span>
<span class=c>// the converted signature will contain 2n+1 `index`-typed integer arguments,
</span><span class=c>// offset, n sizes and n strides, per memref argument type.
</span><span class=c></span><span class=p>!</span>llvm<span class=p>.</span><span class=kt>func</span><span class=p>&lt;</span>void <span class=p>(</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;,</span> ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=k>i64</span><span class=p>,</span> <span class=k>i64</span><span class=p>,</span> <span class=k>i64</span><span class=p>,</span> <span class=k>i64</span><span class=p>,</span> <span class=k>i64</span><span class=p>)&gt;</span>

<span class=c>// Same rules apply to unranked descriptors:
</span><span class=c></span><span class=p>(</span><span class=kt>memref</span><span class=p>&lt;*</span>xf32<span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>()</span>
<span class=c>// which get converted into their components.
</span><span class=c></span><span class=p>!</span>llvm<span class=p>.</span><span class=kt>func</span><span class=p>&lt;</span>void <span class=p>(</span><span class=k>i64</span><span class=p>,</span> ptr<span class=p>&lt;</span><span class=k>i8</span><span class=p>&gt;)&gt;</span>

<span class=c>// However, returning a memref from a function is not affected:
</span><span class=c></span><span class=p>()</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;)</span>
<span class=c>// gets converted to a function returning a descriptor structure.
</span><span class=c></span><span class=p>!</span>llvm<span class=p>.</span><span class=kt>func</span><span class=p>&lt;</span>struct<span class=p>&lt;(</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;,</span> ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=k>i64</span><span class=p>,</span> array<span class=p>&lt;</span><span class=m>1x</span><span class=k>i64</span><span class=p>&gt;,</span> array<span class=p>&lt;</span><span class=m>1x</span><span class=k>i64</span><span class=p>&gt;)&gt;</span> <span class=p>()&gt;</span>

<span class=c>// If multiple memref-typed results are returned:
</span><span class=c></span><span class=p>()</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=k>f64</span><span class=p>&gt;)</span>
<span class=c>// their descriptor structures are additionally packed into another structure,
</span><span class=c>// potentially with other non-memref typed results.
</span><span class=c></span><span class=p>!</span>llvm<span class=p>.</span><span class=kt>func</span><span class=p>&lt;</span>struct<span class=p>&lt;(</span>struct<span class=p>&lt;(</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;,</span> ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=k>i64</span><span class=p>)&gt;,</span>
                   struct<span class=p>&lt;(</span>ptr<span class=p>&lt;</span>double<span class=p>&gt;,</span> ptr<span class=p>&lt;</span>double<span class=p>&gt;,</span> <span class=k>i64</span><span class=p>)&gt;)&gt;</span> <span class=p>()&gt;</span>
</code></pre></div><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/LLVMDialectMemRefConvention/ title="Built-in Function and MemRef Calling Convention"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Built-in Function and MemRef Calling Convention</a>
<a class="nav nav-next" href=/docs/DataLayout/ title="Data Layout Modeling">Next - Data Layout Modeling <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Debugging/>Debugging</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tools/LinalgOpDsl/>linalg_opdsl tool</a></li><li><a href=/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li></ul></li><li><a href=/docs/MemRefPasses/></a></li><li><a href=/docs/EDSC/>Background: declarative builders API</a></li><li><a href=/docs/BufferDeallocationInternals/>Buffer Deallocation - Internals</a></li><li><a href=/docs/Bufferization/>Bufferization</a></li><li><a href=/docs/LLVMDialectMemRefConvention/>Built-in Function and MemRef Calling Convention</a></li><li class=active><a href=/docs/ConversionToLLVMDialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/DataLayout/>Data Layout Modeling</a></li><li><a href=/docs/DebugActions/>Debug Actions</a></li><li><a href=/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li class=has-sub-menu><a href=/docs/Dialects/>Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Dialects/DLTIDialect/></a></li><li><a href=/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=/docs/Dialects/Linalg/>'linalg' Dialect</a></li><li><a href=/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li><a href=/docs/Dialects/OpenMPDialect/>'omp' Dialect</a></li><li><a href=/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>'spv' Dialect</a></li><li><a href=/docs/Dialects/Standard/>'std' Dialect</a></li><li><a href=/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li></ul></li><li><a href=/docs/Interfaces/>Interfaces</a></li><li><a href=/docs/CAPI/>MLIR C API</a></li><li><a href=/docs/LangRef/>MLIR Language Reference</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=/docs/OpDefinitions/>Operation Definition Specification (ODS)</a></li><li><a href=/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=/docs/Passes/>Passes</a></li><li><a href=/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=/docs/ShapeInference/>Shape Inference</a></li><li><a href=/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/Traits/>Traits</a></li><li class=has-sub-menu><a href=/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=/docs/Tutorials/DefiningAttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>