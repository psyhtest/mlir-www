<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'arm_sve' Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.80.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/ArmSVE/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><script type=text/javascript src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li></ul></nav></div><div class=content-container><main><h1>'arm_sve' Dialect</h1><p>Basic dialect to target Arm SVE architectures
This dialect contains the definitions necessary to target Arm SVE scalable
vector operations, including a scalable vector type and intrinsics for
some Arm SVE instructions.</p><p><nav id=TableOfContents><ul><li><a href=#type-constraint-definition>Type constraint definition</a><ul><li><a href=#scalable-vector-type>scalable vector type</a></li><li><a href=#scalable-vector-type-1>Scalable vector type</a></li></ul></li><li><a href=#operation-definition>Operation definition</a><ul><li><a href=#arm_sveintrsdot-mlirarm_svesdotintrop><code>arm_sve.intr.sdot</code> (::mlir::arm_sve::SdotIntrOp)</a></li><li><a href=#arm_svesdot-mlirarm_svesdotop><code>arm_sve.sdot</code> (::mlir::arm_sve::SdotOp)</a></li><li><a href=#arm_sveintrsmmla-mlirarm_svesmmlaintrop><code>arm_sve.intr.smmla</code> (::mlir::arm_sve::SmmlaIntrOp)</a></li><li><a href=#arm_svesmmla-mlirarm_svesmmlaop><code>arm_sve.smmla</code> (::mlir::arm_sve::SmmlaOp)</a></li><li><a href=#arm_sveintrudot-mlirarm_sveudotintrop><code>arm_sve.intr.udot</code> (::mlir::arm_sve::UdotIntrOp)</a></li><li><a href=#arm_sveudot-mlirarm_sveudotop><code>arm_sve.udot</code> (::mlir::arm_sve::UdotOp)</a></li><li><a href=#arm_sveintrummla-mlirarm_sveummlaintrop><code>arm_sve.intr.ummla</code> (::mlir::arm_sve::UmmlaIntrOp)</a></li><li><a href=#arm_sveummla-mlirarm_sveummlaop><code>arm_sve.ummla</code> (::mlir::arm_sve::UmmlaOp)</a></li><li><a href=#arm_svevscale-mlirarm_svevectorscaleintrop><code>arm_sve.vscale</code> (::mlir::arm_sve::VectorScaleIntrOp)</a></li><li><a href=#arm_svevector_scale-mlirarm_svevectorscaleop><code>arm_sve.vector_scale</code> (::mlir::arm_sve::VectorScaleOp)</a></li></ul></li><li><a href=#type-definition>Type definition</a><ul><li><a href=#scalablevectortype>ScalableVectorType</a></li></ul></li></ul></nav><h2 id=type-constraint-definition>Type constraint definition&nbsp;<a class=headline-hash href=#type-constraint-definition>¶</a></h2><h3 id=scalable-vector-type>scalable vector type&nbsp;<a class=headline-hash href=#scalable-vector-type>¶</a></h3><p><code>arm_sve.vector</code> represents vectors that will be processed by a scalable
vector architecture.</p><h3 id=scalable-vector-type-1>Scalable vector type&nbsp;<a class=headline-hash href=#scalable-vector-type-1>¶</a></h3><p>A type representing scalable length SIMD vectors. Unlike fixed-length SIMD
vectors, whose size is constant and known at compile time, scalable
vectors' length is constant but determined by the specific hardware at
run time.</p><h2 id=operation-definition>Operation definition&nbsp;<a class=headline-hash href=#operation-definition>¶</a></h2><h3 id=arm_sveintrsdot-mlirarm_svesdotintrop><code>arm_sve.intr.sdot</code> (::mlir::arm_sve::SdotIntrOp)&nbsp;<a class=headline-hash href=#arm_sveintrsdot-mlirarm_svesdotintrop>¶</a></h3><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>LLVM dialect-compatible vector type</td></tr><tr><td style=text-align:center>«unnamed»</td><td>LLVM dialect-compatible vector type</td></tr><tr><td style=text-align:center>«unnamed»</td><td>LLVM dialect-compatible vector type</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=arm_svesdot-mlirarm_svesdotop><code>arm_sve.sdot</code> (::mlir::arm_sve::SdotOp)&nbsp;<a class=headline-hash href=#arm_svesdot-mlirarm_svesdotop>¶</a></h3><p>Vector-vector dot product and accumulate op</p><p>Syntax:</p><pre><code>operation ::= `arm_sve.sdot` $acc `,` $src1 `,` $src2 attr-dict `:` type($src1) `to` type($dst)
</code></pre><p>SDOT: Signed integer addition of dot product.</p><p>This function maps to the SDOT instruction, and it takes signless integer
operands that the operation interprets as signed. It partitions the second
and third vector inputs into groups of four elements. They calculate the dot
product of each group (without loss of precision) and then add each result
to the overlapping element of the first vector input.</p><p>Source:
<a href=https://developer.arm.com/documentation/100987/0000>https://developer.arm.com/documentation/100987/0000</a></p><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>acc</code></td><td>scalable vector of 32-bit signless integer or 64-bit signless integer values of length 4/2</td></tr><tr><td style=text-align:center><code>src1</code></td><td>scalable vector of 8-bit signless integer or 16-bit signless integer values of length 16/8</td></tr><tr><td style=text-align:center><code>src2</code></td><td>scalable vector of 8-bit signless integer or 16-bit signless integer values of length 16/8</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dst</code></td><td>scalable vector of 32-bit signless integer or 64-bit signless integer values of length 4/2</td></tr></tbody></table><h3 id=arm_sveintrsmmla-mlirarm_svesmmlaintrop><code>arm_sve.intr.smmla</code> (::mlir::arm_sve::SmmlaIntrOp)&nbsp;<a class=headline-hash href=#arm_sveintrsmmla-mlirarm_svesmmlaintrop>¶</a></h3><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>LLVM dialect-compatible vector type</td></tr><tr><td style=text-align:center>«unnamed»</td><td>LLVM dialect-compatible vector type</td></tr><tr><td style=text-align:center>«unnamed»</td><td>LLVM dialect-compatible vector type</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=arm_svesmmla-mlirarm_svesmmlaop><code>arm_sve.smmla</code> (::mlir::arm_sve::SmmlaOp)&nbsp;<a class=headline-hash href=#arm_svesmmla-mlirarm_svesmmlaop>¶</a></h3><p>Matrix-matrix multiply and accumulate op</p><p>Syntax:</p><pre><code>operation ::= `arm_sve.smmla` $acc `,` $src1 `,` $src2 attr-dict `:` type($src1) `to` type($dst)
</code></pre><p>SMMLA: Signed integer matrix multiply-accumulate.</p><p>This function maps to the SMMLA instruction, and it takes signless integer
operands that the operation interprets as signed. It partitions the inputs
into 128-bit quadwords, with the first input containing a row-by-row 2×2
matrix of 32-bit integers, the second input containing a row-by-row 2×8
matrix of 8-bit integers, and the third input containing a column-by-column
8×2 matrix of 8-bit integers. For each quadword, they multiply the second
input matrix by the third input matrix using natural arithmetic and then add
the result to the first input using modular arithmetic.</p><p>Source:
<a href=https://developer.arm.com/documentation/100987/0000>https://developer.arm.com/documentation/100987/0000</a></p><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>acc</code></td><td>scalable vector of 32-bit signless integer values of length 4</td></tr><tr><td style=text-align:center><code>src1</code></td><td>scalable vector of 8-bit signless integer values of length 16</td></tr><tr><td style=text-align:center><code>src2</code></td><td>scalable vector of 8-bit signless integer values of length 16</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dst</code></td><td>scalable vector of 32-bit signless integer values of length 4</td></tr></tbody></table><h3 id=arm_sveintrudot-mlirarm_sveudotintrop><code>arm_sve.intr.udot</code> (::mlir::arm_sve::UdotIntrOp)&nbsp;<a class=headline-hash href=#arm_sveintrudot-mlirarm_sveudotintrop>¶</a></h3><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>LLVM dialect-compatible vector type</td></tr><tr><td style=text-align:center>«unnamed»</td><td>LLVM dialect-compatible vector type</td></tr><tr><td style=text-align:center>«unnamed»</td><td>LLVM dialect-compatible vector type</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=arm_sveudot-mlirarm_sveudotop><code>arm_sve.udot</code> (::mlir::arm_sve::UdotOp)&nbsp;<a class=headline-hash href=#arm_sveudot-mlirarm_sveudotop>¶</a></h3><p>Vector-vector dot product and accumulate op</p><p>Syntax:</p><pre><code>operation ::= `arm_sve.udot` $acc `,` $src1 `,` $src2 attr-dict `:` type($src1) `to` type($dst)
</code></pre><p>UDOT: Unsigned integer addition of dot product.</p><p>This function maps to the UDOT instruction, and it takes signless integer
operands that the operation interprets as unsigned. It partitions the second
and third vector inputs into groups of four elements. They calculate the dot
product of each group (without loss of precision) and then add each result
to the overlapping element of the first vector input.</p><p>Source:
<a href=https://developer.arm.com/documentation/100987/0000>https://developer.arm.com/documentation/100987/0000</a></p><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>acc</code></td><td>scalable vector of 32-bit signless integer or 64-bit signless integer values of length 4/2</td></tr><tr><td style=text-align:center><code>src1</code></td><td>scalable vector of 8-bit signless integer or 16-bit signless integer values of length 16/8</td></tr><tr><td style=text-align:center><code>src2</code></td><td>scalable vector of 8-bit signless integer or 16-bit signless integer values of length 16/8</td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dst</code></td><td>scalable vector of 32-bit signless integer or 64-bit signless integer values of length 4/2</td></tr></tbody></table><h3 id=arm_sveintrummla-mlirarm_sveummlaintrop><code>arm_sve.intr.ummla</code> (::mlir::arm_sve::UmmlaIntrOp)&nbsp;<a class=headline-hash href=#arm_sveintrummla-mlirarm_sveummlaintrop>¶</a></h3><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>LLVM dialect-compatible vector type</td></tr><tr><td style=text-align:center>«unnamed»</td><td>LLVM dialect-compatible vector type</td></tr><tr><td style=text-align:center>«unnamed»</td><td>LLVM dialect-compatible vector type</td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=arm_sveummla-mlirarm_sveummlaop><code>arm_sve.ummla</code> (::mlir::arm_sve::UmmlaOp)&nbsp;<a class=headline-hash href=#arm_sveummla-mlirarm_sveummlaop>¶</a></h3><p>Matrix-matrix multiply and accumulate op</p><p>Syntax:</p><pre><code>operation ::= `arm_sve.ummla` $acc `,` $src1 `,` $src2 attr-dict `:` type($src1) `to` type($dst)
</code></pre><p>UMMLA: Unsigned integer matrix multiply-accumulate.</p><p>This function maps to the UMMLA instruction, and it takes signless integer
operands that the operation interprets as unsigned. It partitions the inputs
into 128-bit quadwords, with the first input containing a row-by-row 2×2
matrix of 32-bit integers, the second input containing a row-by-row 2×8
matrix of 8-bit integers, and the third input containing a column-by-column
8×2 matrix of 8-bit integers. For each quadword, they multiply the second
input matrix by the third input matrix using natural arithmetic and then add
the result to the first input using modular arithmetic.</p><p>Source:
<a href=https://developer.arm.com/documentation/100987/0000>https://developer.arm.com/documentation/100987/0000</a></p><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>acc</code></td><td>scalable vector of 32-bit signless integer values of length 4</td></tr><tr><td style=text-align:center><code>src1</code></td><td>scalable vector of 8-bit signless integer values of length 16</td></tr><tr><td style=text-align:center><code>src2</code></td><td>scalable vector of 8-bit signless integer values of length 16</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dst</code></td><td>scalable vector of 32-bit signless integer values of length 4</td></tr></tbody></table><h3 id=arm_svevscale-mlirarm_svevectorscaleintrop><code>arm_sve.vscale</code> (::mlir::arm_sve::VectorScaleIntrOp)&nbsp;<a class=headline-hash href=#arm_svevscale-mlirarm_svevectorscaleintrop>¶</a></h3><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=arm_svevector_scale-mlirarm_svevectorscaleop><code>arm_sve.vector_scale</code> (::mlir::arm_sve::VectorScaleOp)&nbsp;<a class=headline-hash href=#arm_svevector_scale-mlirarm_svevectorscaleop>¶</a></h3><p>Load vector scale size</p><p>Syntax:</p><pre><code>operation ::= `arm_sve.vector_scale` attr-dict `:` type($res)
</code></pre><p>The vector_scale op returns the scale of the scalable vectors, a positive
integer value that is constant at runtime but unknown at compile time.
The scale of the vector indicates the multiplicity of the vectors and
vector operations. I.e.: an !arm_sve.vector&lt;4xi32> is equivalent to
vector_scale consecutive vector&lt;4xi32>; and an operation on an
!arm_sve.vector&lt;4xi32> is equivalent to performing that operation vector_scale
times, once on each &lt;4xi32> segment of the scalable vector. The vector_scale
op can be used to calculate the step in vector-length agnostic (VLA) loops.</p><h4 id=results-9>Results:&nbsp;<a class=headline-hash href=#results-9>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>index</td></tr></tbody></table><h2 id=type-definition>Type definition&nbsp;<a class=headline-hash href=#type-definition>¶</a></h2><h3 id=scalablevectortype>ScalableVectorType&nbsp;<a class=headline-hash href=#scalablevectortype>¶</a></h3><p>Scalable vector type</p><p>A type representing scalable length SIMD vectors. Unlike fixed-length SIMD
vectors, whose size is constant and known at compile time, scalable
vectors' length is constant but determined by the specific hardware at
run time.</p><h4 id=parameters>Parameters:&nbsp;<a class=headline-hash href=#parameters>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>shape</td><td style=text-align:center><code>::llvm::ArrayRef&lt;int64_t></code></td><td>Vector shape</td></tr><tr><td style=text-align:center>elementType</td><td style=text-align:center><code>Type</code></td><td></td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Dialects/ArmNeon/ title="'arm_neon' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - 'arm_neon' Dialect</a>
<a class="nav nav-next" href=/docs/Dialects/AsyncDialect/ title="'async' Dialect">Next - 'async' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Debugging/>Debugging</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tools/LinalgOpDsl/>linalg_opdsl tool</a></li><li><a href=/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li></ul></li><li><a href=/docs/MemRefPasses/></a></li><li><a href=/docs/EDSC/>Background: declarative builders API</a></li><li><a href=/docs/BufferDeallocationInternals/>Buffer Deallocation - Internals</a></li><li><a href=/docs/Bufferization/>Bufferization</a></li><li><a href=/docs/LLVMDialectMemRefConvention/>Built-in Function and MemRef Calling Convention</a></li><li><a href=/docs/ConversionToLLVMDialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/DataLayout/>Data Layout Modeling</a></li><li><a href=/docs/DebugActions/>Debug Actions</a></li><li><a href=/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li class="parent has-sub-menu"><a href=/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/docs/Dialects/DLTIDialect/></a></li><li><a href=/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li class=active><a href=/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=/docs/Dialects/Linalg/>'linalg' Dialect</a></li><li><a href=/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li><a href=/docs/Dialects/OpenMPDialect/>'omp' Dialect</a></li><li><a href=/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>'spv' Dialect</a></li><li><a href=/docs/Dialects/Standard/>'std' Dialect</a></li><li><a href=/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li></ul></li><li><a href=/docs/Interfaces/>Interfaces</a></li><li><a href=/docs/CAPI/>MLIR C API</a></li><li><a href=/docs/LangRef/>MLIR Language Reference</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=/docs/OpDefinitions/>Operation Definition Specification (ODS)</a></li><li><a href=/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=/docs/Passes/>Passes</a></li><li><a href=/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=/docs/ShapeInference/>Shape Inference</a></li><li><a href=/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/Traits/>Traits</a></li><li class=has-sub-menu><a href=/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=/docs/Tutorials/DefiningAttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>