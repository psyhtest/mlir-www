<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'std' Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.80.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/Standard/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><script type=text/javascript src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li></ul></nav></div><div class=content-container><main><h1>'std' Dialect</h1><p>This dialect provides documentation for operations within the Standard dialect.</p><p>Note: This dialect is a collection of operations for several different concepts,
and should be split into multiple more-focused dialects accordingly.</p><p><strong>Please post an RFC on the
<a href=https://llvm.discourse.group/c/mlir/31>forum</a>
before adding or changing any operation in this dialect.</strong></p><p><nav id=TableOfContents><ul><li><a href=#operations>Operations</a><ul><li><a href=#stdabsf-absfop><code>std.absf</code> (AbsFOp)</a></li><li><a href=#stdaddf-addfop><code>std.addf</code> (AddFOp)</a></li><li><a href=#stdaddi-addiop><code>std.addi</code> (AddIOp)</a></li><li><a href=#stdand-andop><code>std.and</code> (AndOp)</a></li><li><a href=#stdassert-assertop><code>std.assert</code> (AssertOp)</a></li><li><a href=#stdatomic_rmw-atomicrmwop><code>std.atomic_rmw</code> (AtomicRMWOp)</a></li><li><a href=#stdatomic_yield-atomicyieldop><code>std.atomic_yield</code> (AtomicYieldOp)</a></li><li><a href=#stdbr-branchop><code>std.br</code> (BranchOp)</a></li><li><a href=#stdcall_indirect-callindirectop><code>std.call_indirect</code> (CallIndirectOp)</a></li><li><a href=#stdcall-callop><code>std.call</code> (CallOp)</a></li><li><a href=#stdceilf-ceilfop><code>std.ceilf</code> (CeilFOp)</a></li><li><a href=#stdcmpf-cmpfop><code>std.cmpf</code> (CmpFOp)</a></li><li><a href=#stdcmpi-cmpiop><code>std.cmpi</code> (CmpIOp)</a></li><li><a href=#stdcond_br-condbranchop><code>std.cond_br</code> (CondBranchOp)</a></li><li><a href=#stdconstant-constantop><code>std.constant</code> (ConstantOp)</a></li><li><a href=#stdcopysign-copysignop><code>std.copysign</code> (CopySignOp)</a></li><li><a href=#stddivf-divfop><code>std.divf</code> (DivFOp)</a></li><li><a href=#stdfpext-fpextop><code>std.fpext</code> (FPExtOp)</a></li><li><a href=#stdfptosi-fptosiop><code>std.fptosi</code> (FPToSIOp)</a></li><li><a href=#stdfptoui-fptouiop><code>std.fptoui</code> (FPToUIOp)</a></li><li><a href=#stdfptrunc-fptruncop><code>std.fptrunc</code> (FPTruncOp)</a></li><li><a href=#stdfloorf-floorfop><code>std.floorf</code> (FloorFOp)</a></li><li><a href=#stdfmaf-fmafop><code>std.fmaf</code> (FmaFOp)</a></li><li><a href=#stdgeneric_atomic_rmw-genericatomicrmwop><code>std.generic_atomic_rmw</code> (GenericAtomicRMWOp)</a></li><li><a href=#stdindex_cast-indexcastop><code>std.index_cast</code> (IndexCastOp)</a></li><li><a href=#stdmulf-mulfop><code>std.mulf</code> (MulFOp)</a></li><li><a href=#stdmuli-muliop><code>std.muli</code> (MulIOp)</a></li><li><a href=#stdnegf-negfop><code>std.negf</code> (NegFOp)</a></li><li><a href=#stdor-orop><code>std.or</code> (OrOp)</a></li><li><a href=#stdrank-rankop><code>std.rank</code> (RankOp)</a></li><li><a href=#stdremf-remfop><code>std.remf</code> (RemFOp)</a></li><li><a href=#stdreturn-returnop><code>std.return</code> (ReturnOp)</a></li><li><a href=#stdsitofp-sitofpop><code>std.sitofp</code> (SIToFPOp)</a></li><li><a href=#stdselect-selectop><code>std.select</code> (SelectOp)</a></li><li><a href=#stdshift_left-shiftleftop><code>std.shift_left</code> (ShiftLeftOp)</a></li><li><a href=#stdsexti-signextendiop><code>std.sexti</code> (SignExtendIOp)</a></li><li><a href=#stdceildivi_signed-signedceildiviop><code>std.ceildivi_signed</code> (SignedCeilDivIOp)</a></li><li><a href=#stddivi_signed-signeddiviop><code>std.divi_signed</code> (SignedDivIOp)</a></li><li><a href=#stdfloordivi_signed-signedfloordiviop><code>std.floordivi_signed</code> (SignedFloorDivIOp)</a></li><li><a href=#stdremi_signed-signedremiop><code>std.remi_signed</code> (SignedRemIOp)</a></li><li><a href=#stdshift_right_signed-signedshiftrightop><code>std.shift_right_signed</code> (SignedShiftRightOp)</a></li><li><a href=#stdsplat-splatop><code>std.splat</code> (SplatOp)</a></li><li><a href=#stdsubf-subfop><code>std.subf</code> (SubFOp)</a></li><li><a href=#stdsubi-subiop><code>std.subi</code> (SubIOp)</a></li><li><a href=#stdsubtensor_insert-subtensorinsertop><code>std.subtensor_insert</code> (SubTensorInsertOp)</a></li><li><a href=#stdsubtensor-subtensorop><code>std.subtensor</code> (SubTensorOp)</a></li><li><a href=#stdswitch-switchop><code>std.switch</code> (SwitchOp)</a></li><li><a href=#stdtrunci-truncateiop><code>std.trunci</code> (TruncateIOp)</a></li><li><a href=#stduitofp-uitofpop><code>std.uitofp</code> (UIToFPOp)</a></li><li><a href=#stddivi_unsigned-unsigneddiviop><code>std.divi_unsigned</code> (UnsignedDivIOp)</a></li><li><a href=#stdremi_unsigned-unsignedremiop><code>std.remi_unsigned</code> (UnsignedRemIOp)</a></li><li><a href=#stdshift_right_unsigned-unsignedshiftrightop><code>std.shift_right_unsigned</code> (UnsignedShiftRightOp)</a></li><li><a href=#stdxor-xorop><code>std.xor</code> (XOrOp)</a></li><li><a href=#stdzexti-zeroextendiop><code>std.zexti</code> (ZeroExtendIOp)</a></li></ul></li></ul></nav><h2 id=operations>Operations&nbsp;<a class=headline-hash href=#operations>¶</a></h2><h3 id=stdabsf-absfop><code>std.absf</code> (AbsFOp)&nbsp;<a class=headline-hash href=#stdabsf-absfop>¶</a></h3><p>floating point absolute-value operation</p><p>The <code>absf</code> operation computes the absolute value. It takes one operand and
returns one result of the same type. This type may be a float scalar type,
a vector whose element type is float, or a tensor of floats.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar absolute value.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> absf <span class=nv>%b</span> <span class=p>:</span> <span class=k>f64</span>

<span class=c>// SIMD vector element-wise absolute value.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> absf <span class=nv>%g</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise absolute value.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> absf <span class=nv>%y</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span>f8<span class=p>&gt;</span>
</code></pre></div><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdaddf-addfop><code>std.addf</code> (AddFOp)&nbsp;<a class=headline-hash href=#stdaddf-addfop>¶</a></h3><p>floating point addition operation</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `std.addf` ssa-use `,` ssa-use `:` type
</code></pre><p>The <code>addf</code> operation takes two operands and returns one result, each of
these is required to be the same type. This type may be a floating point
scalar type, a vector whose element type is a floating point type, or a
floating point tensor.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar addition.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> addf <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>f64</span>

<span class=c>// SIMD vector addition, e.g. for Intel SSE.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> addf <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Tensor addition.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> addf <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>bf16</span><span class=p>&gt;</span>
</code></pre></div><p>TODO: In the distant future, this will accept optional attributes for fast
math, contraction, rounding mode, and other controls.</p><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>floating-point-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=stdaddi-addiop><code>std.addi</code> (AddIOp)&nbsp;<a class=headline-hash href=#stdaddi-addiop>¶</a></h3><p>integer addition operation</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `std.addi` ssa-use `,` ssa-use `:` type
</code></pre><p>The <code>addi</code> operation takes two operands and returns one result, each of
these is required to be the same type. This type may be an integer scalar
type, a vector whose element type is integer, or a tensor of integers. It
has no standard attributes.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar addition.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> addi <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i64</span>

<span class=c>// SIMD vector element-wise addition, e.g. for Intel SSE.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> addi <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise addition.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> addi <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>i8</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=stdand-andop><code>std.and</code> (AndOp)&nbsp;<a class=headline-hash href=#stdand-andop>¶</a></h3><p>integer binary and</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `std.and` ssa-use `,` ssa-use `:` type
</code></pre><p>The <code>and</code> operation takes two operands and returns one result, each of these
is required to be the same type. This type may be an integer scalar type, a
vector whose element type is integer, or a tensor of integers. It has no
standard attributes.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar integer bitwise and.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> and <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i64</span>

<span class=c>// SIMD vector element-wise bitwise integer and.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> and <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise bitwise integer and.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> and <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>i8</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=stdassert-assertop><code>std.assert</code> (AssertOp)&nbsp;<a class=headline-hash href=#stdassert-assertop>¶</a></h3><p>Assert operation with message attribute</p><p>Syntax:</p><pre><code>operation ::= `std.assert` $arg `,` $msg attr-dict
</code></pre><p>Assert operation with single boolean operand and an error message attribute.
If the argument is <code>true</code> this operation has no effect. Otherwise, the
program execution will abort. The provided error message may be used by a
runtime to propagate the error to the user.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>assert <span class=nv>%b</span><span class=p>,</span> <span class=s>&#34;Expected ... to be true&#34;</span>
</code></pre></div><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>msg</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>arg</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=stdatomic_rmw-atomicrmwop><code>std.atomic_rmw</code> (AtomicRMWOp)&nbsp;<a class=headline-hash href=#stdatomic_rmw-atomicrmwop>¶</a></h3><p>atomic read-modify-write operation</p><p>Syntax:</p><pre><code>operation ::= `std.atomic_rmw` $kind $value `,` $memref `[` $indices `]` attr-dict `:` `(` type($value) `,`
              type($memref) `)` `-&gt;` type($result)
</code></pre><p>The <code>atomic_rmw</code> operation provides a way to perform a read-modify-write
sequence that is free from data races. The kind enumeration specifies the
modification to perform. The value operand represents the new value to be
applied during the modification. The memref operand represents the buffer
that the read and write will be performed against, as accessed by the
specified indices. The arity of the indices is the rank of the memref. The
result represents the latest value that was stored.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%x</span> <span class=p>=</span> atomic_rmw <span class=s>&#34;addf&#34;</span> <span class=nv>%value</span><span class=p>,</span> <span class=nv>%I</span><span class=p>[</span><span class=nv>%i</span><span class=p>]</span> <span class=p>:</span> <span class=p>(</span><span class=k>f32</span><span class=p>,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x</span><span class=k>f32</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=k>f32</span>
</code></pre></div><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>kind</code></td><td style=text-align:center>::mlir::AtomicRMWKindAttr</td><td>allowed 64-bit signless integer cases: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10</td></tr></tbody></table><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>signless integer or floating-point</td></tr><tr><td style=text-align:center><code>memref</code></td><td>memref of signless integer or floating-point values</td></tr><tr><td style=text-align:center><code>indices</code></td><td>index</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer or floating-point</td></tr></tbody></table><h3 id=stdatomic_yield-atomicyieldop><code>std.atomic_yield</code> (AtomicYieldOp)&nbsp;<a class=headline-hash href=#stdatomic_yield-atomicyieldop>¶</a></h3><p>yield operation for GenericAtomicRMWOp</p><p>Syntax:</p><pre><code>operation ::= `std.atomic_yield` $result attr-dict `:` type($result)
</code></pre><p>&ldquo;atomic_yield&rdquo; yields an SSA value from a GenericAtomicRMWOp region.</p><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=stdbr-branchop><code>std.br</code> (BranchOp)&nbsp;<a class=headline-hash href=#stdbr-branchop>¶</a></h3><p>branch operation</p><p>Syntax:</p><pre><code>operation ::= `std.br` $dest (`(` $destOperands^ `:` type($destOperands) `)`)? attr-dict
</code></pre><p>The <code>br</code> operation represents a branch operation in a function.
The operation takes variable number of operands and produces no results.
The operand number and types for each successor must match the arguments of
the block successor.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nl>^bb2</span><span class=p>:</span>
  <span class=nv>%2</span> <span class=p>=</span> call <span class=nf>@someFn</span><span class=p>()</span>
  br <span class=nl>^bb3</span><span class=p>(</span><span class=nv>%2</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;*</span>xf32<span class=p>&gt;)</span>
<span class=nl>^bb3</span><span class=p>(</span><span class=nv>%3</span><span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;*</span>xf32<span class=p>&gt;):</span>
</code></pre></div><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>destOperands</code></td><td>any type</td></tr></tbody></table><h4 id=successors>Successors:&nbsp;<a class=headline-hash href=#successors>¶</a></h4><table><thead><tr><th style=text-align:center>Successor</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dest</code></td><td>any successor</td></tr></tbody></table><h3 id=stdcall_indirect-callindirectop><code>std.call_indirect</code> (CallIndirectOp)&nbsp;<a class=headline-hash href=#stdcall_indirect-callindirectop>¶</a></h3><p>indirect call operation</p><p>Syntax:</p><pre><code>operation ::= `std.call_indirect` $callee `(` $operands `)` attr-dict `:` type($callee)
</code></pre><p>The <code>call_indirect</code> operation represents an indirect call to a value of
function type. Functions are first class types in MLIR, and may be passed as
arguments and merged together with block arguments. The operands and result
types of the call must match the specified function type.</p><p>Function values can be created with the
<a href=#stdconstant-constantop><code>constant</code> operation</a>
.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%31</span> <span class=p>=</span> call_indirect <span class=nv>%15</span><span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span><span class=p>)</span>
        <span class=p>:</span> <span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>16x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>16x</span><span class=k>f32</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>16x</span><span class=k>f32</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>callee</code></td><td>function type</td></tr><tr><td style=text-align:center><code>operands</code></td><td>any type</td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>results</code></td><td>any type</td></tr></tbody></table><h3 id=stdcall-callop><code>std.call</code> (CallOp)&nbsp;<a class=headline-hash href=#stdcall-callop>¶</a></h3><p>call operation</p><p>Syntax:</p><pre><code>operation ::= `std.call` $callee `(` $operands `)` attr-dict `:` functional-type($operands, results)
</code></pre><p>The <code>call</code> operation represents a direct call to a function that is within
the same symbol scope as the call. The operands and result types of the
call must match the specified function type. The callee is encoded as a
symbol reference attribute named &ldquo;callee&rdquo;.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%2</span> <span class=p>=</span> call <span class=nf>@my_add</span><span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>f32</span><span class=p>,</span> <span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>f32</span>
</code></pre></div><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>callee</code></td><td style=text-align:center>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></tbody></table><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operands</code></td><td>any type</td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdceilf-ceilfop><code>std.ceilf</code> (CeilFOp)&nbsp;<a class=headline-hash href=#stdceilf-ceilfop>¶</a></h3><p>ceiling of the specified value</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `std.ceilf` ssa-use `:` type
</code></pre><p>The <code>ceilf</code> operation computes the ceiling of a given value. It takes one
operand and returns one result of the same type. This type may be a float
scalar type, a vector whose element type is float, or a tensor of floats.
It has no standard attributes.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar ceiling value.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> ceilf <span class=nv>%b</span> <span class=p>:</span> <span class=k>f64</span>

<span class=c>// SIMD vector element-wise ceiling value.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> ceilf <span class=nv>%g</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise ceiling value.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> ceilf <span class=nv>%y</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span>f8<span class=p>&gt;</span>
</code></pre></div><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdcmpf-cmpfop><code>std.cmpf</code> (CmpFOp)&nbsp;<a class=headline-hash href=#stdcmpf-cmpfop>¶</a></h3><p>floating-point comparison operation</p><p>Syntax:</p><pre><code>operation ::= `std.cmpf` $predicate `,` $lhs `,` $rhs attr-dict `:` type($lhs)
</code></pre><p>The <code>cmpf</code> operation compares its two operands according to the float
comparison rules and the predicate specified by the respective attribute.
The predicate defines the type of comparison: (un)orderedness, (in)equality
and signed less/greater than (or equal to) as well as predicates that are
always true or false. The operands must have the same type, and this type
must be a float type, or a vector or tensor thereof. The result is an i1,
or a vector/tensor thereof having the same shape as the inputs. Unlike cmpi,
the operands are always treated as signed. The u prefix indicates
<em>unordered</em> comparison, not unsigned comparison, so &ldquo;une&rdquo; means unordered or
not equal. For the sake of readability by humans, custom assembly form for
the operation uses a string-typed attribute for the predicate. The value of
this attribute corresponds to lower-cased name of the predicate constant,
e.g., &ldquo;one&rdquo; means &ldquo;ordered not equal&rdquo;. The string representation of the
attribute is merely a syntactic sugar and is converted to an integer
attribute by the parser.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%r1</span> <span class=p>=</span> cmpf <span class=s>&#34;oeq&#34;</span> <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>f32</span>
<span class=nv>%r2</span> <span class=p>=</span> cmpf <span class=s>&#34;ult&#34;</span> <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>42x42x</span><span class=k>f64</span><span class=p>&gt;</span>
<span class=nv>%r3</span> <span class=p>=</span> <span class=s>&#34;std.cmpf&#34;</span><span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span><span class=p>)</span> <span class=p>{</span>predicate<span class=p>:</span> <span class=m>0</span><span class=p>}</span> <span class=p>:</span> <span class=p>(</span>f8<span class=p>,</span> f8<span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i1</span>
</code></pre></div><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>predicate</code></td><td style=text-align:center>::mlir::CmpFPredicateAttr</td><td>allowed 64-bit signless integer cases: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15</td></tr></tbody></table><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>floating-point-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool-like</td></tr></tbody></table><h3 id=stdcmpi-cmpiop><code>std.cmpi</code> (CmpIOp)&nbsp;<a class=headline-hash href=#stdcmpi-cmpiop>¶</a></h3><p>integer comparison operation</p><p>Syntax:</p><pre><code>operation ::= `std.cmpi` $predicate `,` $lhs `,` $rhs attr-dict `:` type($lhs)
</code></pre><p>The <code>cmpi</code> operation is a generic comparison for integer-like types. Its two
arguments can be integers, vectors or tensors thereof as long as their types
match. The operation produces an i1 for the former case, a vector or a
tensor of i1 with the same shape as inputs in the other cases.</p><p>Its first argument is an attribute that defines which type of comparison is
performed. The following comparisons are supported:</p><ul><li>equal (mnemonic: <code>"eq"</code>; integer value: <code>0</code>)</li><li>not equal (mnemonic: <code>"ne"</code>; integer value: <code>1</code>)</li><li>signed less than (mnemonic: <code>"slt"</code>; integer value: <code>2</code>)</li><li>signed less than or equal (mnemonic: <code>"sle"</code>; integer value: <code>3</code>)</li><li>signed greater than (mnemonic: <code>"sgt"</code>; integer value: <code>4</code>)</li><li>signed greater than or equal (mnemonic: <code>"sge"</code>; integer value: <code>5</code>)</li><li>unsigned less than (mnemonic: <code>"ult"</code>; integer value: <code>6</code>)</li><li>unsigned less than or equal (mnemonic: <code>"ule"</code>; integer value: <code>7</code>)</li><li>unsigned greater than (mnemonic: <code>"ugt"</code>; integer value: <code>8</code>)</li><li>unsigned greater than or equal (mnemonic: <code>"uge"</code>; integer value: <code>9</code>)</li></ul><p>The result is <code>1</code> if the comparison is true and <code>0</code> otherwise. For vector or
tensor operands, the comparison is performed elementwise and the element of
the result indicates whether the comparison is true for the operand elements
with the same indices as those of the result.</p><p>Note: while the custom assembly form uses strings, the actual underlying
attribute has integer type (or rather enum class in C++ code) as seen from
the generic assembly form. String literals are used to improve readability
of the IR by humans.</p><p>This operation only applies to integer-like operands, but not floats. The
main reason being that comparison operations have diverging sets of
attributes: integers require sign specification while floats require various
floating point-related particularities, e.g., <code>-ffast-math</code> behavior,
IEEE754 compliance, etc
(
<a href=/docs/Rationale/Rationale/>rationale</a>
).
The type of comparison is specified as attribute to avoid introducing ten
similar operations, taking into account that they are often implemented
using the same operation downstream
(
<a href=/docs/Rationale/Rationale/>rationale</a>
). The
separation between signed and unsigned order comparisons is necessary
because of integers being signless. The comparison operation must know how
to interpret values with the foremost bit being set: negatives in two&rsquo;s
complement or large positives
(
<a href=/docs/Rationale/Rationale/>rationale</a>
).</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Custom form of scalar &#34;signed less than&#34; comparison.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> cmpi <span class=s>&#34;slt&#34;</span><span class=p>,</span> <span class=nv>%lhs</span><span class=p>,</span> <span class=nv>%rhs</span> <span class=p>:</span> <span class=k>i32</span>

<span class=c>// Generic form of the same operation.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> <span class=s>&#34;std.cmpi&#34;</span><span class=p>(</span><span class=nv>%lhs</span><span class=p>,</span> <span class=nv>%rhs</span><span class=p>)</span> <span class=p>{</span><span class=nl>predicate =</span> <span class=m>2</span> <span class=p>:</span> <span class=k>i64</span><span class=p>}</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i1</span>

<span class=c>// Custom form of vector equality comparison.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> cmpi <span class=s>&#34;eq&#34;</span><span class=p>,</span> <span class=nv>%lhs</span><span class=p>,</span> <span class=nv>%rhs</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i64</span><span class=p>&gt;</span>

<span class=c>// Generic form of the same operation.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> <span class=s>&#34;std.cmpi&#34;</span><span class=p>(</span><span class=nv>%lhs</span><span class=p>,</span> <span class=nv>%rhs</span><span class=p>)</span> <span class=p>{</span><span class=nl>predicate =</span> <span class=m>0</span> <span class=p>:</span> <span class=k>i64</span><span class=p>}</span>
    <span class=p>:</span> <span class=p>(</span><span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i64</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i64</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i1</span><span class=p>&gt;</span>
</code></pre></div><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>predicate</code></td><td style=text-align:center>::mlir::CmpIPredicateAttr</td><td>allowed 64-bit signless integer cases: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9</td></tr></tbody></table><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-9>Results:&nbsp;<a class=headline-hash href=#results-9>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool-like</td></tr></tbody></table><h3 id=stdcond_br-condbranchop><code>std.cond_br</code> (CondBranchOp)&nbsp;<a class=headline-hash href=#stdcond_br-condbranchop>¶</a></h3><p>conditional branch operation</p><p>Syntax:</p><pre><code>operation ::= `std.cond_br` $condition `,`
              $trueDest (`(` $trueDestOperands^ `:` type($trueDestOperands) `)`)? `,`
              $falseDest (`(` $falseDestOperands^ `:` type($falseDestOperands) `)`)?
              attr-dict
</code></pre><p>The <code>cond_br</code> terminator operation represents a conditional branch on a
boolean (1-bit integer) value. If the bit is set, then the first destination
is jumped to; if it is false, the second destination is chosen. The count
and types of operands must align with the arguments in the corresponding
target blocks.</p><p>The MLIR conditional branch operation is not allowed to target the entry
block for a region. The two destinations of the conditional branch operation
are allowed to be the same.</p><p>The following example illustrates a function with a conditional branch
operation that targets the same block.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@select</span><span class=p>(</span><span class=nv>%a</span><span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=nv>%b</span><span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=nv>%flag</span><span class=p>:</span> <span class=k>i1</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i32</span> <span class=p>{</span>
  <span class=c>// Both targets are the same, operands differ
</span><span class=c></span>  cond_br <span class=nv>%flag</span><span class=p>,</span> <span class=nl>^bb1</span><span class=p>(</span><span class=nv>%a</span> <span class=p>:</span> <span class=k>i32</span><span class=p>),</span> <span class=nl>^bb1</span><span class=p>(</span><span class=nv>%b</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span>

<span class=nl>^bb1</span><span class=p>(</span><span class=nv>%x</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>:</span>
  <span class=kt>return</span> <span class=nv>%x</span> <span class=p>:</span> <span class=k>i32</span>
<span class=p>}</span>
</code></pre></div><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>condition</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>trueDestOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>falseDestOperands</code></td><td>any type</td></tr></tbody></table><h4 id=successors-1>Successors:&nbsp;<a class=headline-hash href=#successors-1>¶</a></h4><table><thead><tr><th style=text-align:center>Successor</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>trueDest</code></td><td>any successor</td></tr><tr><td style=text-align:center><code>falseDest</code></td><td>any successor</td></tr></tbody></table><h3 id=stdconstant-constantop><code>std.constant</code> (ConstantOp)&nbsp;<a class=headline-hash href=#stdconstant-constantop>¶</a></h3><p>constant</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `std.constant` attribute-value `:` type
</code></pre><p>The <code>constant</code> operation produces an SSA value equal to some constant
specified by an attribute. This is the way that MLIR uses to form simple
integer and floating point constants, as well as more exotic things like
references to functions and tensor/vector constants.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Integer constant
</span><span class=c></span><span class=nv>%1</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>42</span> <span class=p>:</span> <span class=k>i32</span>

<span class=c>// Reference to function @myfn.
</span><span class=c></span><span class=nv>%3</span> <span class=p>=</span> <span class=kt>constant</span> <span class=nf>@myfn</span> <span class=p>:</span> <span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>16x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>16x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Equivalent generic forms
</span><span class=c></span><span class=nv>%1</span> <span class=p>=</span> <span class=s>&#34;std.constant&#34;</span><span class=p>()</span> <span class=p>{</span><span class=nl>value =</span> <span class=m>42</span> <span class=p>:</span> <span class=k>i32</span><span class=p>}</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=k>i32</span>
<span class=nv>%3</span> <span class=p>=</span> <span class=s>&#34;std.constant&#34;</span><span class=p>()</span> <span class=p>{</span><span class=nl>value =</span> <span class=nf>@myfn</span><span class=p>}</span>
   <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>((</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>16x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>16x</span><span class=k>f32</span><span class=p>&gt;)</span>
</code></pre></div><p>MLIR does not allow direct references to functions in SSA operands because
the compiler is multithreaded, and disallowing SSA values to directly
reference a function simplifies this
(
<a href=/docs/Rationale/Rationale/>rationale</a>
).</p><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td style=text-align:center>::mlir::Attribute</td><td>any attribute</td></tr></tbody></table><h4 id=results-10>Results:&nbsp;<a class=headline-hash href=#results-10>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdcopysign-copysignop><code>std.copysign</code> (CopySignOp)&nbsp;<a class=headline-hash href=#stdcopysign-copysignop>¶</a></h3><p>A copysign operation</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `std.copysign` ssa-use `,` ssa-use `:` type
</code></pre><p>The <code>copysign</code> returns a value with the magnitude of the first operand and
the sign of the second operand. It takes two operands and returns one
result of the same type. This type may be a float scalar type, a vector
whose element type is float, or a tensor of floats. It has no standard
attributes.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar copysign value.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> copysign <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>f64</span>

<span class=c>// SIMD vector element-wise copysign value.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> copysign <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise copysign value.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> copysign <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span>f8<span class=p>&gt;</span>
</code></pre></div><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>floating-point-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-11>Results:&nbsp;<a class=headline-hash href=#results-11>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=stddivf-divfop><code>std.divf</code> (DivFOp)&nbsp;<a class=headline-hash href=#stddivf-divfop>¶</a></h3><p>floating point division operation</p><h4 id=operands-15>Operands:&nbsp;<a class=headline-hash href=#operands-15>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>floating-point-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-12>Results:&nbsp;<a class=headline-hash href=#results-12>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=stdfpext-fpextop><code>std.fpext</code> (FPExtOp)&nbsp;<a class=headline-hash href=#stdfpext-fpextop>¶</a></h3><p>cast from floating-point to wider floating-point</p><p>Cast a floating-point value to a larger floating-point-typed value.
The destination type must to be strictly wider than the source type.
Only scalars are currently supported.</p><h4 id=operands-16>Operands:&nbsp;<a class=headline-hash href=#operands-16>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>any type</td></tr></tbody></table><h4 id=results-13>Results:&nbsp;<a class=headline-hash href=#results-13>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdfptosi-fptosiop><code>std.fptosi</code> (FPToSIOp)&nbsp;<a class=headline-hash href=#stdfptosi-fptosiop>¶</a></h3><p>cast from floating-point type to integer type</p><p>Cast from a value interpreted as floating-point to the nearest (rounding
towards zero) signed integer value.</p><h4 id=operands-17>Operands:&nbsp;<a class=headline-hash href=#operands-17>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>any type</td></tr></tbody></table><h4 id=results-14>Results:&nbsp;<a class=headline-hash href=#results-14>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdfptoui-fptouiop><code>std.fptoui</code> (FPToUIOp)&nbsp;<a class=headline-hash href=#stdfptoui-fptouiop>¶</a></h3><p>cast from floating-point type to integer type</p><p>Cast from a value interpreted as floating-point to the nearest (rounding
towards zero) unsigned integer value.</p><h4 id=operands-18>Operands:&nbsp;<a class=headline-hash href=#operands-18>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>any type</td></tr></tbody></table><h4 id=results-15>Results:&nbsp;<a class=headline-hash href=#results-15>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdfptrunc-fptruncop><code>std.fptrunc</code> (FPTruncOp)&nbsp;<a class=headline-hash href=#stdfptrunc-fptruncop>¶</a></h3><p>cast from floating-point to narrower floating-point</p><p>Truncate a floating-point value to a smaller floating-point-typed value.
The destination type must be strictly narrower than the source type.
If the value cannot be exactly represented, it is rounded using the default
rounding mode. Only scalars are currently supported.</p><h4 id=operands-19>Operands:&nbsp;<a class=headline-hash href=#operands-19>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>any type</td></tr></tbody></table><h4 id=results-16>Results:&nbsp;<a class=headline-hash href=#results-16>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdfloorf-floorfop><code>std.floorf</code> (FloorFOp)&nbsp;<a class=headline-hash href=#stdfloorf-floorfop>¶</a></h3><p>floor of the specified value</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `std.floorf` ssa-use `:` type
</code></pre><p>The <code>floorf</code> operation computes the floor of a given value. It takes one
operand and returns one result of the same type. This type may be a float
scalar type, a vector whose element type is float, or a tensor of floats.
It has no standard attributes.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar floor value.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> floorf <span class=nv>%b</span> <span class=p>:</span> <span class=k>f64</span>

<span class=c>// SIMD vector element-wise floor value.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> floorf <span class=nv>%g</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise floor value.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> floorf <span class=nv>%y</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span>f8<span class=p>&gt;</span>
</code></pre></div><h4 id=operands-20>Operands:&nbsp;<a class=headline-hash href=#operands-20>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-17>Results:&nbsp;<a class=headline-hash href=#results-17>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdfmaf-fmafop><code>std.fmaf</code> (FmaFOp)&nbsp;<a class=headline-hash href=#stdfmaf-fmafop>¶</a></h3><p>floating point fused multipy-add operation</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `std.fmaf` ssa-use `,` ssa-use `,` ssa-use `:` type
</code></pre><p>The <code>fmaf</code> operation takes three operands and returns one result, each of
these is required to be the same type. This type may be a floating point
scalar type, a vector whose element type is a floating point type, or a
floating point tensor.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar fused multiply-add: d = a*b + c
</span><span class=c></span><span class=nv>%d</span> <span class=p>=</span> fmaf <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>f64</span>

<span class=c>// SIMD vector fused multiply-add, e.g. for Intel SSE.
</span><span class=c></span><span class=nv>%i</span> <span class=p>=</span> fmaf <span class=nv>%f</span><span class=p>,</span> <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Tensor fused multiply-add.
</span><span class=c></span><span class=nv>%w</span> <span class=p>=</span> fmaf <span class=nv>%x</span><span class=p>,</span> <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>bf16</span><span class=p>&gt;</span>
</code></pre></div><p>The semantics of the operation correspond to those of the <code>llvm.fma</code>
<a href=https://llvm.org/docs/LangRef.html#llvm-fma-intrinsic>intrinsic</a>
. In the
particular case of lowering to LLVM, this is guaranteed to lower
to the <code>llvm.fma.*</code> intrinsic.</p><h4 id=operands-21>Operands:&nbsp;<a class=headline-hash href=#operands-21>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>floating-point-like</td></tr><tr><td style=text-align:center><code>b</code></td><td>floating-point-like</td></tr><tr><td style=text-align:center><code>c</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-18>Results:&nbsp;<a class=headline-hash href=#results-18>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=stdgeneric_atomic_rmw-genericatomicrmwop><code>std.generic_atomic_rmw</code> (GenericAtomicRMWOp)&nbsp;<a class=headline-hash href=#stdgeneric_atomic_rmw-genericatomicrmwop>¶</a></h3><p>atomic read-modify-write operation with a region</p><p>The <code>generic_atomic_rmw</code> operation provides a way to perform a read-modify-write
sequence that is free from data races. The memref operand represents the
buffer that the read and write will be performed against, as accessed by
the specified indices. The arity of the indices is the rank of the memref.
The result represents the latest value that was stored. The region contains
the code for the modification itself. The entry block has a single argument
that represents the value stored in <code>memref[indices]</code> before the write is
performed. No side-effecting ops are allowed in the body of
<code>GenericAtomicRMWOp</code>.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%x</span> <span class=p>=</span> generic_atomic_rmw <span class=nv>%I</span><span class=p>[</span><span class=nv>%i</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>{</span>
  <span class=nl>^bb0</span><span class=p>(</span><span class=nv>%current_value</span> <span class=p>:</span> <span class=k>f32</span><span class=p>):</span>
    <span class=nv>%c1</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>1.0</span> <span class=p>:</span> <span class=k>f32</span>
    <span class=nv>%inc</span> <span class=p>=</span> addf <span class=nv>%c1</span><span class=p>,</span> <span class=nv>%current_value</span> <span class=p>:</span> <span class=k>f32</span>
    atomic_yield <span class=nv>%inc</span> <span class=p>:</span> <span class=k>f32</span>
<span class=p>}</span>
</code></pre></div><h4 id=operands-22>Operands:&nbsp;<a class=headline-hash href=#operands-22>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>memref</code></td><td>memref of signless integer or floating-point values</td></tr><tr><td style=text-align:center><code>indices</code></td><td>index</td></tr></tbody></table><h4 id=results-19>Results:&nbsp;<a class=headline-hash href=#results-19>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless integer or floating-point</td></tr></tbody></table><h3 id=stdindex_cast-indexcastop><code>std.index_cast</code> (IndexCastOp)&nbsp;<a class=headline-hash href=#stdindex_cast-indexcastop>¶</a></h3><p>cast between index and integer types</p><p>Casts between integer scalars and &lsquo;index&rsquo; scalars. Index is an integer of
platform-specific bit width. If casting to a wider integer, the value is
sign-extended. If casting to a narrower integer, the value is truncated.</p><h4 id=operands-23>Operands:&nbsp;<a class=headline-hash href=#operands-23>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>any type</td></tr></tbody></table><h4 id=results-20>Results:&nbsp;<a class=headline-hash href=#results-20>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdmulf-mulfop><code>std.mulf</code> (MulFOp)&nbsp;<a class=headline-hash href=#stdmulf-mulfop>¶</a></h3><p>floating point multiplication operation</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `std.mulf` ssa-use `,` ssa-use `:` type
</code></pre><p>The <code>mulf</code> operation takes two operands and returns one result, each of
these is required to be the same type. This type may be a floating point
scalar type, a vector whose element type is a floating point type, or a
floating point tensor.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar multiplication.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> mulf <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>f64</span>

<span class=c>// SIMD pointwise vector multiplication, e.g. for Intel SSE.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> mulf <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Tensor pointwise multiplication.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> mulf <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>bf16</span><span class=p>&gt;</span>
</code></pre></div><p>TODO: In the distant future, this will accept optional attributes for fast
math, contraction, rounding mode, and other controls.</p><h4 id=operands-24>Operands:&nbsp;<a class=headline-hash href=#operands-24>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>floating-point-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-21>Results:&nbsp;<a class=headline-hash href=#results-21>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=stdmuli-muliop><code>std.muli</code> (MulIOp)&nbsp;<a class=headline-hash href=#stdmuli-muliop>¶</a></h3><p>integer multiplication operation</p><h4 id=operands-25>Operands:&nbsp;<a class=headline-hash href=#operands-25>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-22>Results:&nbsp;<a class=headline-hash href=#results-22>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=stdnegf-negfop><code>std.negf</code> (NegFOp)&nbsp;<a class=headline-hash href=#stdnegf-negfop>¶</a></h3><p>floating point negation</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `negf` ssa-use `:` type
</code></pre><p>The <code>negf</code> operation computes the negation of a given value. It takes one
operand and returns one result of the same type. This type may be a float
scalar type, a vector whose element type is float, or a tensor of floats.
It has no standard attributes.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar negation value.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> negf <span class=nv>%b</span> <span class=p>:</span> <span class=k>f64</span>

<span class=c>// SIMD vector element-wise negation value.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> negf <span class=nv>%g</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise negation value.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> negf <span class=nv>%y</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span>f8<span class=p>&gt;</span>
</code></pre></div><h4 id=operands-26>Operands:&nbsp;<a class=headline-hash href=#operands-26>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-23>Results:&nbsp;<a class=headline-hash href=#results-23>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdor-orop><code>std.or</code> (OrOp)&nbsp;<a class=headline-hash href=#stdor-orop>¶</a></h3><p>integer binary or</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `or` ssa-use `,` ssa-use `:` type
</code></pre><p>The <code>or</code> operation takes two operands and returns one result, each of these
is required to be the same type. This type may be an integer scalar type, a
vector whose element type is integer, or a tensor of integers. It has no
standard attributes.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar integer bitwise or.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> or <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i64</span>

<span class=c>// SIMD vector element-wise bitwise integer or.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> or <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise bitwise integer or.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> or <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>i8</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operands-27>Operands:&nbsp;<a class=headline-hash href=#operands-27>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-24>Results:&nbsp;<a class=headline-hash href=#results-24>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=stdrank-rankop><code>std.rank</code> (RankOp)&nbsp;<a class=headline-hash href=#stdrank-rankop>¶</a></h3><p>rank operation</p><p>Syntax:</p><pre><code>operation ::= `std.rank` $memrefOrTensor attr-dict `:` type($memrefOrTensor)
</code></pre><p>The <code>rank</code> operation takes a memref/tensor operand and returns its rank.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%1</span> <span class=p>=</span> rank <span class=nv>%arg0</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;*</span>xf32<span class=p>&gt;</span>
<span class=nv>%2</span> <span class=p>=</span> rank <span class=nv>%arg1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;*</span>xf32<span class=p>&gt;</span>
</code></pre></div><h4 id=operands-28>Operands:&nbsp;<a class=headline-hash href=#operands-28>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>memrefOrTensor</code></td><td>any memref or tensor type</td></tr></tbody></table><h4 id=results-25>Results:&nbsp;<a class=headline-hash href=#results-25>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>index</td></tr></tbody></table><h3 id=stdremf-remfop><code>std.remf</code> (RemFOp)&nbsp;<a class=headline-hash href=#stdremf-remfop>¶</a></h3><p>floating point division remainder operation</p><h4 id=operands-29>Operands:&nbsp;<a class=headline-hash href=#operands-29>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>floating-point-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-26>Results:&nbsp;<a class=headline-hash href=#results-26>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=stdreturn-returnop><code>std.return</code> (ReturnOp)&nbsp;<a class=headline-hash href=#stdreturn-returnop>¶</a></h3><p>return operation</p><p>Syntax:</p><pre><code>operation ::= `std.return` attr-dict ($operands^ `:` type($operands))?
</code></pre><p>The <code>return</code> operation represents a return operation within a function.
The operation takes variable number of operands and produces no results.
The operand number and types must match the signature of the function
that contains the operation.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=kt>func</span> <span class=nf>@foo</span><span class=p>()</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> f8<span class=p>)</span> <span class=p>{</span>
  <span class=p>...</span>
  <span class=kt>return</span> <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> f8
<span class=p>}</span>
</code></pre></div><h4 id=operands-30>Operands:&nbsp;<a class=headline-hash href=#operands-30>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operands</code></td><td>any type</td></tr></tbody></table><h3 id=stdsitofp-sitofpop><code>std.sitofp</code> (SIToFPOp)&nbsp;<a class=headline-hash href=#stdsitofp-sitofpop>¶</a></h3><p>cast from integer type to floating-point</p><p>Cast from a value interpreted as signed or vector of signed integers to the
corresponding floating-point scalar or vector value. If the value cannot be
exactly represented, it is rounded using the default rounding mode. Scalars
and vector types are currently supported.</p><h4 id=operands-31>Operands:&nbsp;<a class=headline-hash href=#operands-31>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>any type</td></tr></tbody></table><h4 id=results-27>Results:&nbsp;<a class=headline-hash href=#results-27>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stdselect-selectop><code>std.select</code> (SelectOp)&nbsp;<a class=headline-hash href=#stdselect-selectop>¶</a></h3><p>select operation</p><p>The <code>select</code> operation chooses one value based on a binary condition
supplied as its first operand. If the value of the first operand is <code>1</code>,
the second operand is chosen, otherwise the third operand is chosen.
The second and the third operand must have the same type.</p><p>The operation applies to vectors and tensors elementwise given the <em>shape</em>
of all operands is identical. The choice is made for each element
individually based on the value at the same position as the element in the
condition operand. If an i1 is provided as the condition, the entire vector
or tensor is chosen.</p><p>The <code>select</code> operation combined with
<a href=#stdcmpi-cmpiop><code>cmpi</code></a>
can be used
to implement <code>min</code> and <code>max</code> with signed or unsigned comparison semantics.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Custom form of scalar selection.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> select <span class=nv>%cond</span><span class=p>,</span> <span class=nv>%true</span><span class=p>,</span> <span class=nv>%false</span> <span class=p>:</span> <span class=k>i32</span>

<span class=c>// Generic form of the same operation.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> <span class=s>&#34;std.select&#34;</span><span class=p>(</span><span class=nv>%cond</span><span class=p>,</span> <span class=nv>%true</span><span class=p>,</span> <span class=nv>%false</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>i1</span><span class=p>,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i32</span>

<span class=c>// Element-wise vector selection.
</span><span class=c></span><span class=nv>%vx</span> <span class=p>=</span> std<span class=p>.</span>select <span class=nv>%vcond</span><span class=p>,</span> <span class=nv>%vtrue</span><span class=p>,</span> <span class=nv>%vfalse</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>42x</span><span class=k>i1</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>42x</span><span class=k>f32</span><span class=p>&gt;</span>

<span class=c>// Full vector selection.
</span><span class=c></span><span class=nv>%vx</span> <span class=p>=</span> std<span class=p>.</span>select <span class=nv>%cond</span><span class=p>,</span> <span class=nv>%vtrue</span><span class=p>,</span> <span class=nv>%vfalse</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>42x</span><span class=k>f32</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operands-32>Operands:&nbsp;<a class=headline-hash href=#operands-32>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>condition</code></td><td>bool-like</td></tr><tr><td style=text-align:center><code>true_value</code></td><td>any type</td></tr><tr><td style=text-align:center><code>false_value</code></td><td>any type</td></tr></tbody></table><h4 id=results-28>Results:&nbsp;<a class=headline-hash href=#results-28>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=stdshift_left-shiftleftop><code>std.shift_left</code> (ShiftLeftOp)&nbsp;<a class=headline-hash href=#stdshift_left-shiftleftop>¶</a></h3><p>integer left-shift</p><p>The shift_left operation shifts an integer value to the left by a variable
amount. The low order bits are filled with zeros.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%1</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>5</span> <span class=p>:</span> <span class=k>i8</span>                       <span class=c>// %1 is 0b00000101
</span><span class=c></span><span class=nv>%2</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>3</span> <span class=p>:</span> <span class=k>i8</span>
<span class=nv>%3</span> <span class=p>=</span> shift_left <span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span> <span class=p>:</span> <span class=p>(</span><span class=k>i8</span><span class=p>,</span> <span class=k>i8</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i8</span>    <span class=c>// %3 is 0b00101000
</span></code></pre></div><h4 id=operands-33>Operands:&nbsp;<a class=headline-hash href=#operands-33>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-29>Results:&nbsp;<a class=headline-hash href=#results-29>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=stdsexti-signextendiop><code>std.sexti</code> (SignExtendIOp)&nbsp;<a class=headline-hash href=#stdsexti-signextendiop>¶</a></h3><p>integer sign extension operation</p><p>The integer sign extension operation takes an integer input of
width M and an integer destination type of width N. The destination
bit-width must be larger than the input bit-width (N > M).
The top-most (N - M) bits of the output are filled with copies
of the most-significant bit of the input.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%1</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>5</span> <span class=p>:</span> <span class=k>i3</span>            <span class=c>// %1 is 0b101
</span><span class=c></span><span class=nv>%2</span> <span class=p>=</span> sexti <span class=nv>%1</span> <span class=p>:</span> <span class=k>i3</span> to <span class=k>i6</span>        <span class=c>// %2 is 0b111101
</span><span class=c></span><span class=nv>%3</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>2</span> <span class=p>:</span> <span class=k>i3</span>            <span class=c>// %3 is 0b010
</span><span class=c></span><span class=nv>%4</span> <span class=p>=</span> sexti <span class=nv>%3</span> <span class=p>:</span> <span class=k>i3</span> to <span class=k>i6</span>        <span class=c>// %4 is 0b000010
</span><span class=c></span>
<span class=nv>%5</span> <span class=p>=</span> sexti <span class=nv>%0</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2 x</span> <span class=k>i32</span><span class=p>&gt;</span> to <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2 x</span> <span class=k>i64</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operands-34>Operands:&nbsp;<a class=headline-hash href=#operands-34>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-30>Results:&nbsp;<a class=headline-hash href=#results-30>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>signless-integer-like</td></tr></tbody></table><h3 id=stdceildivi_signed-signedceildiviop><code>std.ceildivi_signed</code> (SignedCeilDivIOp)&nbsp;<a class=headline-hash href=#stdceildivi_signed-signedceildiviop>¶</a></h3><p>signed ceil integer division operation</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `ceildivi_signed` ssa-use `,` ssa-use `:` type
</code></pre><p>Signed integer division. Rounds towards positive infinity, i.e. <code>7 / -2 = -3</code>.</p><p>Note: the semantics of division by zero or signed division overflow (minimum
value divided by -1) is TBD; do NOT assume any specific behavior.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar signed integer division.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> ceildivi_signed <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i64</span>
</code></pre></div><h4 id=operands-35>Operands:&nbsp;<a class=headline-hash href=#operands-35>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-31>Results:&nbsp;<a class=headline-hash href=#results-31>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=stddivi_signed-signeddiviop><code>std.divi_signed</code> (SignedDivIOp)&nbsp;<a class=headline-hash href=#stddivi_signed-signeddiviop>¶</a></h3><p>signed integer division operation</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `divi_signed` ssa-use `,` ssa-use `:` type
</code></pre><p>Signed integer division. Rounds towards zero. Treats the leading bit as
sign, i.e. <code>6 / -2 = -3</code>.</p><p>Note: the semantics of division by zero or signed division overflow (minimum
value divided by -1) is TBD; do NOT assume any specific behavior.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar signed integer division.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> divi_signed <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i64</span>

<span class=c>// SIMD vector element-wise division.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> divi_signed <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise integer division.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> divi_signed <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>i8</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operands-36>Operands:&nbsp;<a class=headline-hash href=#operands-36>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-32>Results:&nbsp;<a class=headline-hash href=#results-32>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=stdfloordivi_signed-signedfloordiviop><code>std.floordivi_signed</code> (SignedFloorDivIOp)&nbsp;<a class=headline-hash href=#stdfloordivi_signed-signedfloordiviop>¶</a></h3><p>signed floor integer division operation</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `floordivi_signed` ssa-use `,` ssa-use `:` type
</code></pre><p>Signed integer division. Rounds towards negative infinity, i.e. <code>5 / -2 = -3</code>.</p><p>Note: the semantics of division by zero or signed division overflow (minimum
value divided by -1) is TBD; do NOT assume any specific behavior.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar signed integer division.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> floordivi_signed <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i64</span>

</code></pre></div><h4 id=operands-37>Operands:&nbsp;<a class=headline-hash href=#operands-37>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-33>Results:&nbsp;<a class=headline-hash href=#results-33>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=stdremi_signed-signedremiop><code>std.remi_signed</code> (SignedRemIOp)&nbsp;<a class=headline-hash href=#stdremi_signed-signedremiop>¶</a></h3><p>signed integer division remainder operation</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `std.remi_signed` ssa-use `,` ssa-use `:` type
</code></pre><p>Signed integer division remainder. Treats the leading bit as sign, i.e. <code>6 % -2 = 0</code>.</p><p>Note: the semantics of division by zero is TBD; do NOT assume any specific
behavior.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar signed integer division remainder.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> remi_signed <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i64</span>

<span class=c>// SIMD vector element-wise division remainder.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> remi_signed <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise integer division remainder.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> remi_signed <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>i8</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operands-38>Operands:&nbsp;<a class=headline-hash href=#operands-38>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-34>Results:&nbsp;<a class=headline-hash href=#results-34>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=stdshift_right_signed-signedshiftrightop><code>std.shift_right_signed</code> (SignedShiftRightOp)&nbsp;<a class=headline-hash href=#stdshift_right_signed-signedshiftrightop>¶</a></h3><p>signed integer right-shift</p><p>The shift_right_signed operation shifts an integer value to the right by
a variable amount. The integer is interpreted as signed. The high order
bits in the output are filled with copies of the most-significant bit
of the shifted value (which means that the sign of the value is preserved).</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%1</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>160</span> <span class=p>:</span> <span class=k>i8</span>                             <span class=c>// %1 is 0b10100000
</span><span class=c></span><span class=nv>%2</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>3</span> <span class=p>:</span> <span class=k>i8</span>
<span class=nv>%3</span> <span class=p>=</span> shift_right_signed <span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span> <span class=p>:</span> <span class=p>(</span><span class=k>i8</span><span class=p>,</span> <span class=k>i8</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i8</span>    <span class=c>// %3 is 0b11110100
</span><span class=c></span><span class=nv>%4</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>96</span> <span class=p>:</span> <span class=k>i8</span>                              <span class=c>// %4 is 0b01100000
</span><span class=c></span><span class=nv>%5</span> <span class=p>=</span> shift_right_signed <span class=nv>%4</span><span class=p>,</span> <span class=nv>%2</span> <span class=p>:</span> <span class=p>(</span><span class=k>i8</span><span class=p>,</span> <span class=k>i8</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i8</span>    <span class=c>// %5 is 0b00001100
</span></code></pre></div><h4 id=operands-39>Operands:&nbsp;<a class=headline-hash href=#operands-39>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-35>Results:&nbsp;<a class=headline-hash href=#results-35>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=stdsplat-splatop><code>std.splat</code> (SplatOp)&nbsp;<a class=headline-hash href=#stdsplat-splatop>¶</a></h3><p>splat or broadcast operation</p><p>Syntax:</p><pre><code>operation ::= `std.splat` $input attr-dict `:` type($aggregate)
</code></pre><p>Broadcast the operand to all elements of the result vector or tensor. The
operand has to be of integer/index/float type. When the result is a tensor,
it has to be statically shaped.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%s</span> <span class=p>=</span> load <span class=nv>%A</span><span class=p>[</span><span class=nv>%i</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>128x</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=nv>%v</span> <span class=p>=</span> splat <span class=nv>%s</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
<span class=nv>%t</span> <span class=p>=</span> splat <span class=nv>%s</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>8x16x</span><span class=k>i32</span><span class=p>&gt;</span>
</code></pre></div><p>TODO: This operation is easy to extend to broadcast to dynamically shaped
tensors in the same way dynamically shaped memrefs are handled.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Broadcasts %s to a 2-d dynamically shaped tensor, with %m, %n binding
</span><span class=c>// to the sizes of the two dynamic dimensions.
</span><span class=c></span><span class=nv>%m</span> <span class=p>=</span> <span class=s>&#34;foo&#34;</span><span class=p>()</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>index</span><span class=p>)</span>
<span class=nv>%n</span> <span class=p>=</span> <span class=s>&#34;bar&#34;</span><span class=p>()</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>index</span><span class=p>)</span>
<span class=nv>%t</span> <span class=p>=</span> splat <span class=nv>%s</span> <span class=p>[</span><span class=nv>%m</span><span class=p>,</span> <span class=nv>%n</span><span class=p>]</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>i32</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operands-40>Operands:&nbsp;<a class=headline-hash href=#operands-40>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>integer/index/float type</td></tr></tbody></table><h4 id=results-36>Results:&nbsp;<a class=headline-hash href=#results-36>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>aggregate</code></td><td>vector of any type values or statically shaped tensor of any type values</td></tr></tbody></table><h3 id=stdsubf-subfop><code>std.subf</code> (SubFOp)&nbsp;<a class=headline-hash href=#stdsubf-subfop>¶</a></h3><p>floating point subtraction operation</p><h4 id=operands-41>Operands:&nbsp;<a class=headline-hash href=#operands-41>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>floating-point-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-37>Results:&nbsp;<a class=headline-hash href=#results-37>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=stdsubi-subiop><code>std.subi</code> (SubIOp)&nbsp;<a class=headline-hash href=#stdsubi-subiop>¶</a></h3><p>integer subtraction operation</p><h4 id=operands-42>Operands:&nbsp;<a class=headline-hash href=#operands-42>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-38>Results:&nbsp;<a class=headline-hash href=#results-38>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=stdsubtensor_insert-subtensorinsertop><code>std.subtensor_insert</code> (SubTensorInsertOp)&nbsp;<a class=headline-hash href=#stdsubtensor_insert-subtensorinsertop>¶</a></h3><p>subtensor_insert operation</p><p>Syntax:</p><pre><code>operation ::= `std.subtensor_insert` $source `into` $dest ``
              custom&lt;OperandsOrIntegersOffsetsOrStridesList&gt;($offsets, $static_offsets)
              custom&lt;OperandsOrIntegersSizesList&gt;($sizes, $static_sizes)
              custom&lt;OperandsOrIntegersOffsetsOrStridesList&gt;($strides, $static_strides)
              attr-dict `:` type($source) `into` type($dest)
</code></pre><p>The &ldquo;subtensor_insert&rdquo; operation insert a tensor <code>source</code> into another
tensor <code>dest</code> as specified by the operation&rsquo;s offsets, sizes and strides
arguments.</p><p>It returns a copy of <code>dest</code> with the proper subtensor updated with the value
of <code>source</code>.</p><p>The subtensor_insert operation has the encodes the following information:</p><ul><li>source: the tensor that is inserted.</li><li>dest: the tensor into which the source tensor is inserted.</li><li>offsets: tensor-rank number of offsets into the &ldquo;base&rdquo; tensor from which
to extract the subtensor.</li><li>sizes: tensor-rank number of sizes which specify the sizes of the result
tensor type.</li><li>strides: tensor-rank number of strides that specify subsampling in each
dimension.</li></ul><p>The representation based on offsets, sizes and strides support a
partially-static specification via attributes specified through the
<code>static_offsets</code>, <code>static_sizes</code> and <code>static_strides</code> arguments. A special
sentinel value ShapedType::kDynamicSize and
ShapedType::kDynamicStrideOrOffset encodes that the corresponding entry has
a dynamic value.</p><p>After buffer-allocation, the &ldquo;subtensor_insert&rdquo; op is expected to become
an in-place buffer update.</p><h4 id=attributes-6>Attributes:&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>static_offsets</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>64-bit integer array attribute</td></tr><tr><td style=text-align:center><code>static_sizes</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>64-bit integer array attribute</td></tr><tr><td style=text-align:center><code>static_strides</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>64-bit integer array attribute</td></tr></tbody></table><h4 id=operands-43>Operands:&nbsp;<a class=headline-hash href=#operands-43>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>source</code></td><td>ranked tensor of any type values</td></tr><tr><td style=text-align:center><code>dest</code></td><td>ranked tensor of any type values</td></tr><tr><td style=text-align:center><code>offsets</code></td><td>index</td></tr><tr><td style=text-align:center><code>sizes</code></td><td>index</td></tr><tr><td style=text-align:center><code>strides</code></td><td>index</td></tr></tbody></table><h4 id=results-39>Results:&nbsp;<a class=headline-hash href=#results-39>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>ranked tensor of any type values</td></tr></tbody></table><h3 id=stdsubtensor-subtensorop><code>std.subtensor</code> (SubTensorOp)&nbsp;<a class=headline-hash href=#stdsubtensor-subtensorop>¶</a></h3><p>subtensor operation</p><p>Syntax:</p><pre><code>operation ::= `std.subtensor` $source ``
              custom&lt;OperandsOrIntegersOffsetsOrStridesList&gt;($offsets, $static_offsets)
              custom&lt;OperandsOrIntegersSizesList&gt;($sizes, $static_sizes)
              custom&lt;OperandsOrIntegersOffsetsOrStridesList&gt;($strides, $static_strides)
              attr-dict `:` type($source) `to` type($result)
</code></pre><p>The &ldquo;subtensor&rdquo; operation extract a tensor from another tensor as
specified by the operation&rsquo;s offsets, sizes and strides arguments.</p><p>The subtensor operation supports the following arguments:</p><ul><li>source: the &ldquo;base&rdquo; tensor from which to extract a subtensor.</li><li>offsets: tensor-rank number of offsets into the &ldquo;base&rdquo; tensor from which
to extract the subtensor.</li><li>sizes: tensor-rank number of sizes which specify the sizes of the result
tensor type.</li><li>strides: tensor-rank number of strides specifying subsampling in each
dimension.</li></ul><p>The representation based on offsets, sizes and strides support a
partially-static specification via attributes specified through the
<code>static_offsets</code>, <code>static_sizes</code> and <code>static_strides</code> arguments. A special
sentinel value ShapedType::kDynamicSize and
ShapedType::kDynamicStrideOrOffset encodes that the corresponding entry has
a dynamic value.</p><p>After buffer-allocation, the &ldquo;subtensor&rdquo; op is expected to lower into a
&ldquo;subview&rdquo; op.</p><p>A subtensor operation may additionally reduce the rank of the resulting
tensor by removing dimensions that are statically known to be of size 1.</p><p>Example:</p><pre><code>// Rank-reducing subtensor.
%1 = subtensor %0[0, 0, 0][1, 16, 4][1, 1, 1] :
  tensor&lt;8x16x4xf32&gt; to tensor&lt;16x4xf32&gt;
%3 = subtensor %2[3, 4, 2][1, 6, 3][1, 1, 1] :
  tensor&lt;8x16x4xf32&gt; to tensor&lt;6x3xf32&gt;
</code></pre><h4 id=attributes-7>Attributes:&nbsp;<a class=headline-hash href=#attributes-7>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>static_offsets</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>64-bit integer array attribute</td></tr><tr><td style=text-align:center><code>static_sizes</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>64-bit integer array attribute</td></tr><tr><td style=text-align:center><code>static_strides</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>64-bit integer array attribute</td></tr></tbody></table><h4 id=operands-44>Operands:&nbsp;<a class=headline-hash href=#operands-44>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>source</code></td><td>ranked tensor of any type values</td></tr><tr><td style=text-align:center><code>offsets</code></td><td>index</td></tr><tr><td style=text-align:center><code>sizes</code></td><td>index</td></tr><tr><td style=text-align:center><code>strides</code></td><td>index</td></tr></tbody></table><h4 id=results-40>Results:&nbsp;<a class=headline-hash href=#results-40>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>ranked tensor of any type values</td></tr></tbody></table><h3 id=stdswitch-switchop><code>std.switch</code> (SwitchOp)&nbsp;<a class=headline-hash href=#stdswitch-switchop>¶</a></h3><p>switch operation</p><p>Syntax:</p><pre><code>operation ::= `std.switch` $flag `:` type($flag) `,` `[` `\n`
              custom&lt;SwitchOpCases&gt;(ref(type($flag)),$defaultDestination,
              $defaultOperands,
              type($defaultOperands),
              $case_values,
              $caseDestinations,
              $caseOperands,
              type($caseOperands),
              $case_operand_offsets)
              `]`
              attr-dict
</code></pre><p>The <code>switch</code> terminator operation represents a switch on a signless integer
value. If the flag matches one of the specified cases, then the
corresponding destination is jumped to. If the flag does not match any of
the cases, the default destination is jumped to. The count and types of
operands must align with the arguments in the corresponding target blocks.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>switch <span class=nv>%flag</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=p>[</span>
  default<span class=p>:</span> <span class=nl>^bb1</span><span class=p>(</span><span class=nv>%a</span> <span class=p>:</span> <span class=k>i32</span><span class=p>),</span>
  <span class=m>42</span><span class=p>:</span> <span class=nl>^bb1</span><span class=p>(</span><span class=nv>%b</span> <span class=p>:</span> <span class=k>i32</span><span class=p>),</span>
  <span class=m>43</span><span class=p>:</span> <span class=nl>^bb3</span><span class=p>(</span><span class=nv>%c</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span>
<span class=p>]</span>
</code></pre></div><h4 id=attributes-8>Attributes:&nbsp;<a class=headline-hash href=#attributes-8>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>case_values</code></td><td style=text-align:center>::mlir::DenseIntElementsAttr</td><td>integer elements attribute</td></tr><tr><td style=text-align:center><code>case_operand_offsets</code></td><td style=text-align:center>::mlir::DenseIntElementsAttr</td><td>32-bit signless integer elements attribute</td></tr></tbody></table><h4 id=operands-45>Operands:&nbsp;<a class=headline-hash href=#operands-45>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>flag</code></td><td>integer</td></tr><tr><td style=text-align:center><code>defaultOperands</code></td><td>any type</td></tr><tr><td style=text-align:center><code>caseOperands</code></td><td>any type</td></tr></tbody></table><h4 id=successors-2>Successors:&nbsp;<a class=headline-hash href=#successors-2>¶</a></h4><table><thead><tr><th style=text-align:center>Successor</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>defaultDestination</code></td><td>any successor</td></tr><tr><td style=text-align:center><code>caseDestinations</code></td><td>any successor</td></tr></tbody></table><h3 id=stdtrunci-truncateiop><code>std.trunci</code> (TruncateIOp)&nbsp;<a class=headline-hash href=#stdtrunci-truncateiop>¶</a></h3><p>integer truncation operation</p><p>The integer truncation operation takes an integer input of
width M and an integer destination type of width N. The destination
bit-width must be smaller than the input bit-width (N &lt; M).
The top-most (N - M) bits of the input are discarded.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>  <span class=nv>%1</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>21</span> <span class=p>:</span> <span class=k>i5</span>           <span class=c>// %1 is 0b10101
</span><span class=c></span>  <span class=nv>%2</span> <span class=p>=</span> trunci <span class=nv>%1</span> <span class=p>:</span> <span class=k>i5</span> to <span class=k>i4</span>       <span class=c>// %2 is 0b0101
</span><span class=c></span>  <span class=nv>%3</span> <span class=p>=</span> trunci <span class=nv>%1</span> <span class=p>:</span> <span class=k>i5</span> to <span class=k>i3</span>       <span class=c>// %3 is 0b101
</span><span class=c></span>
  <span class=nv>%5</span> <span class=p>=</span> trunci <span class=nv>%0</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2 x</span> <span class=k>i32</span><span class=p>&gt;</span> to <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2 x</span> <span class=k>i16</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operands-46>Operands:&nbsp;<a class=headline-hash href=#operands-46>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-41>Results:&nbsp;<a class=headline-hash href=#results-41>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>signless-integer-like</td></tr></tbody></table><h3 id=stduitofp-uitofpop><code>std.uitofp</code> (UIToFPOp)&nbsp;<a class=headline-hash href=#stduitofp-uitofpop>¶</a></h3><p>cast from unsigned integer type to floating-point</p><p>Cast from a value interpreted as unsigned integer or vector of unsigned
integers to the corresponding scalar or vector floating-point value. If the
value cannot be exactly represented, it is rounded using the default
rounding mode. Scalars and vector types are currently supported.</p><h4 id=operands-47>Operands:&nbsp;<a class=headline-hash href=#operands-47>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>any type</td></tr></tbody></table><h4 id=results-42>Results:&nbsp;<a class=headline-hash href=#results-42>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=stddivi_unsigned-unsigneddiviop><code>std.divi_unsigned</code> (UnsignedDivIOp)&nbsp;<a class=headline-hash href=#stddivi_unsigned-unsigneddiviop>¶</a></h3><p>unsigned integer division operation</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `std.divi_unsigned` ssa-use `,` ssa-use `:` type
</code></pre><p>Unsigned integer division. Rounds towards zero. Treats the leading bit as
the most significant, i.e. for <code>i16</code> given two&rsquo;s complement representation,
<code>6 / -2 = 6 / (2^16 - 2) = 0</code>.</p><p>Note: the semantics of division by zero is TBD; do NOT assume any specific
behavior.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar unsigned integer division.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> divi_unsigned <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i64</span>

<span class=c>// SIMD vector element-wise division.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> divi_unsigned <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise integer division.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> divi_unsigned <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>i8</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operands-48>Operands:&nbsp;<a class=headline-hash href=#operands-48>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-43>Results:&nbsp;<a class=headline-hash href=#results-43>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=stdremi_unsigned-unsignedremiop><code>std.remi_unsigned</code> (UnsignedRemIOp)&nbsp;<a class=headline-hash href=#stdremi_unsigned-unsignedremiop>¶</a></h3><p>unsigned integer division remainder operation</p><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `std.remi_unsigned` ssa-use `,` ssa-use `:` type
</code></pre><p>Unsigned integer division remainder. Treats the leading bit as the most
significant, i.e. for <code>i16</code>, <code>6 % -2 = 6 % (2^16 - 2) = 6</code>.</p><p>Note: the semantics of division by zero is TBD; do NOT assume any specific
behavior.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar unsigned integer division remainder.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> remi_unsigned <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i64</span>

<span class=c>// SIMD vector element-wise division remainder.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> remi_unsigned <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise integer division remainder.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> remi_unsigned <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>i8</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operands-49>Operands:&nbsp;<a class=headline-hash href=#operands-49>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-44>Results:&nbsp;<a class=headline-hash href=#results-44>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=stdshift_right_unsigned-unsignedshiftrightop><code>std.shift_right_unsigned</code> (UnsignedShiftRightOp)&nbsp;<a class=headline-hash href=#stdshift_right_unsigned-unsignedshiftrightop>¶</a></h3><p>unsigned integer right-shift</p><p>The shift_right_unsigned operation shifts an integer value to the right by
a variable amount. The integer is interpreted as unsigned. The high order
bits are always filled with zeros.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%1</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>160</span> <span class=p>:</span> <span class=k>i8</span>                               <span class=c>// %1 is 0b10100000
</span><span class=c></span><span class=nv>%2</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>3</span> <span class=p>:</span> <span class=k>i8</span>
<span class=nv>%3</span> <span class=p>=</span> shift_right_unsigned <span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span> <span class=p>:</span> <span class=p>(</span><span class=k>i8</span><span class=p>,</span> <span class=k>i8</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i8</span>    <span class=c>// %3 is 0b00010100
</span></code></pre></div><h4 id=operands-50>Operands:&nbsp;<a class=headline-hash href=#operands-50>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-45>Results:&nbsp;<a class=headline-hash href=#results-45>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=stdxor-xorop><code>std.xor</code> (XOrOp)&nbsp;<a class=headline-hash href=#stdxor-xorop>¶</a></h3><p>integer binary xor</p><p>The <code>xor</code> operation takes two operands and returns one result, each of these
is required to be the same type. This type may be an integer scalar type, a
vector whose element type is integer, or a tensor of integers. It has no
standard attributes.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=c>// Scalar integer bitwise xor.
</span><span class=c></span><span class=nv>%a</span> <span class=p>=</span> xor <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i64</span>

<span class=c>// SIMD vector element-wise bitwise integer xor.
</span><span class=c></span><span class=nv>%f</span> <span class=p>=</span> xor <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>

<span class=c>// Tensor element-wise bitwise integer xor.
</span><span class=c></span><span class=nv>%x</span> <span class=p>=</span> xor <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>i8</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operands-51>Operands:&nbsp;<a class=headline-hash href=#operands-51>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-46>Results:&nbsp;<a class=headline-hash href=#results-46>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=stdzexti-zeroextendiop><code>std.zexti</code> (ZeroExtendIOp)&nbsp;<a class=headline-hash href=#stdzexti-zeroextendiop>¶</a></h3><p>integer zero extension operation</p><p>The integer zero extension operation takes an integer input of
width M and an integer destination type of width N. The destination
bit-width must be larger than the input bit-width (N > M).
The top-most (N - M) bits of the output are filled with zeros.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>  <span class=nv>%1</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>5</span> <span class=p>:</span> <span class=k>i3</span>            <span class=c>// %1 is 0b101
</span><span class=c></span>  <span class=nv>%2</span> <span class=p>=</span> zexti <span class=nv>%1</span> <span class=p>:</span> <span class=k>i3</span> to <span class=k>i6</span>        <span class=c>// %2 is 0b000101
</span><span class=c></span>  <span class=nv>%3</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>2</span> <span class=p>:</span> <span class=k>i3</span>            <span class=c>// %3 is 0b010
</span><span class=c></span>  <span class=nv>%4</span> <span class=p>=</span> zexti <span class=nv>%3</span> <span class=p>:</span> <span class=k>i3</span> to <span class=k>i6</span>        <span class=c>// %4 is 0b000010
</span><span class=c></span>
  <span class=nv>%5</span> <span class=p>=</span> zexti <span class=nv>%0</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2 x</span> <span class=k>i32</span><span class=p>&gt;</span> to <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2 x</span> <span class=k>i64</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operands-52>Operands:&nbsp;<a class=headline-hash href=#operands-52>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-47>Results:&nbsp;<a class=headline-hash href=#results-47>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>signless-integer-like</td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Dialects/SPIR-V/ title="'spv' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - 'spv' Dialect</a>
<a class="nav nav-next" href=/docs/Dialects/TensorOps/ title="'tensor' Dialect">Next - 'tensor' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Debugging/>Debugging</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tools/LinalgOpDsl/>linalg_opdsl tool</a></li><li><a href=/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li></ul></li><li><a href=/docs/MemRefPasses/></a></li><li><a href=/docs/EDSC/>Background: declarative builders API</a></li><li><a href=/docs/BufferDeallocationInternals/>Buffer Deallocation - Internals</a></li><li><a href=/docs/Bufferization/>Bufferization</a></li><li><a href=/docs/LLVMDialectMemRefConvention/>Built-in Function and MemRef Calling Convention</a></li><li><a href=/docs/ConversionToLLVMDialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/DataLayout/>Data Layout Modeling</a></li><li><a href=/docs/DebugActions/>Debug Actions</a></li><li><a href=/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li class="parent has-sub-menu"><a href=/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/docs/Dialects/DLTIDialect/></a></li><li><a href=/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=/docs/Dialects/Linalg/>'linalg' Dialect</a></li><li><a href=/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li><a href=/docs/Dialects/OpenMPDialect/>'omp' Dialect</a></li><li><a href=/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>'spv' Dialect</a></li><li class=active><a href=/docs/Dialects/Standard/>'std' Dialect</a></li><li><a href=/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li></ul></li><li><a href=/docs/Interfaces/>Interfaces</a></li><li><a href=/docs/CAPI/>MLIR C API</a></li><li><a href=/docs/LangRef/>MLIR Language Reference</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=/docs/OpDefinitions/>Operation Definition Specification (ODS)</a></li><li><a href=/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=/docs/Passes/>Passes</a></li><li><a href=/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=/docs/ShapeInference/>Shape Inference</a></li><li><a href=/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/Traits/>Traits</a></li><li class=has-sub-menu><a href=/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=/docs/Tutorials/DefiningAttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>